#include "funciones.hpp"
void obtenerArchivos(vector<string> &malwares)
{
    DIR *directorio; //directorio para abrir
    struct dirent *archivos; //archivos que ira leyendo del directorio
    string dir; //directorio

    //abre el directorio "Malware/"
    if (directorio = opendir("Malware/"))
    {
        //mientras que exista un archivo al leer dentro del directorio
        while (archivos = readdir(directorio))
        {
            string nombre(archivos->d_name); //genera el string a partir del nombre obtenido y guardado en la estructura

            //quita los primeros . y .. de los nombres generados por default
            if (nombre.compare(".") != 0 && nombre.compare("..") != 0)
            {
                malwares.push_back(nombre); //guarda los nombres obtenidos en el vector de nombres de malware
            }
        }
    }
    //cierra el directorio
    closedir(directorio);
}

void SHA1(const string &archivo)
{
    //comando a ejecutar, utilizando la herramienta sha1sum concatenando con el directorio y archivo, generando una cadena con awk y enviando el resutlado al archivo "hashes.txt"
    const string comando = "sha1sum Malware/" + archivo + " | awk '{printf \"%45s\\n\", $1}' >> hashes.txt";
    // hace el llamado a sistema utilizando el comando generado
    system(comando.c_str());
}
/*
    Nombre: r2cmd(2)
    Descripcion: funcion que ejecuta en cmd los comandos para radare2
    Parametros: 
    - r2: puntero del pipe radare2
    - cmd: comando a ejecutar 
    Retorna:
    - void
*/
void r2cmd(R2Pipe *r2, const char *cmd) {
    //obiene el mensaje, resultado de ejecutar el comando con la funciion r2pipe_cmd
	char *msg = r2pipe_cmd (r2, cmd);
	if (msg) {
        //imprime el mensaje
		cout << msg<<endl;
        //libera memoria
		free (msg);
	}
}
void obtenerEnsamblador(const int &m, const string &archivo, const string &herramienta,vector<string>& ensambladores)
{
    //instruccion a usar
    string instruccion = "";

    //si la herramienta es Objdump
    if (herramienta.compare("Objdump") == 0)
    {
        //genera la instruccion con el formato de ensamblador y filtro para una arquitectura Intel
        instruccion = "objdump -d --no-show-raw-insn -M intel-mnemonic";
        //genera el comando con la instruccion anterior para el archivo, quedando solo con los opcodes del ensamblador
        const string comando = instruccion + " Malware/" + archivo + " | grep \"^ \" | cut -f2,3 > Ensambladores/" + herramienta + "/Ensamblador_m" + to_string(m) + string(".txt"); 
        //ejecuta el comando
        system(comando.c_str());
    }//si la herramienta es Radare2
    else if (herramienta.compare("Radare2") == 0)
    {
        //direccion a la que se le obtendra su ensamblador utilizando el comando r2
        const string adress="r2 -q0 Malware/" + archivo;
        //obtiene el apuntador r2 con la direccion anterior
        R2Pipe *r2 = r2pipe_open(adress.c_str());
        if (r2)
        {
            //se le aplica las configuraciones necesarias
            r2cmd(r2,"-e bin.cache=true");
            r2cmd(r2,"e asm.bytes=0");
            r2cmd(r2,"aaaa");
            //se le aplica el formato adecuado para solo imprimir los opcodes
            const string comando2 = "pif@@f > Ensambladores/" + herramienta + "/Ensamblador_m" + to_string(m) + string(".txt");
            //ejecuta el comando
            r2cmd(r2, comando2.c_str());
            //cierra radare2
            r2pipe_close(r2);
        }else
            cout << "No se pudo abrir "<< "Malware/" + archivo<<endl; //en caso de error
    }
    //guarda en el vector de ensambladores el nombre del archivo obtenido
    ensambladores.push_back("Ensambladores/" + herramienta + "/Ensamblador_m" + to_string(m) + string(".txt"));
}

void getNGrams(const int& dm,const string& archivo,const string& herramienta){
    fstream file,fileout; //archivos de entrada y salida

    unordered_map<string,int> unigrams; //hash-table donde se guarda los ngram obtenidos
    string linea; //linea que se esta leyendo del archivo
    string opcode; //opcode obtenido
    file.open(archivo, ios::in); //se abre el archivo ensamblador

    //se crea el archivo donde mandaremos los resultados
    string salida="Resultados/"+herramienta+"/NgramD"+to_string(dm)+string(".txt");
    fileout.open(salida, ios::out); //se abre y se configura como salida

    //se lee linea por liena del archivo
    while (getline(file,linea))
    {
        stringstream( linea ) >> opcode; //Se lee solo la primera columna para obtener solo los mnemonicos

        //si ya existe ese mnemonico en la hash-table, aumentar su contador
        if(unigrams.count(opcode))
            unigrams[opcode]++;
        else //en caso contrario, generarlo y poner el contador como 1
            unigrams[opcode]=1;
    }
    //imprime la cabecera de la salida del archivo
    fileout << "Opcode\t\t"<<"Frecuencia"<<endl;
    
    //para cada unigram obtenido
    for (auto & unigram : unigrams)
    {
        //se imprime con un espacio de 10, ->  mnemonico    contador
        fileout << left << setw(10)<< unigram.first<<"\t"<<unigram.second<<endl;
    }
    
}