#include "funciones.hpp"
void obtenerArchivos(vector<string> &malwares)
{
    DIR *directorio;
    struct dirent *archivos;
    string dir;
    if (directorio = opendir("Malware/"))
    {
        while (archivos = readdir(directorio))
        {
            string nombre(archivos->d_name);
            if (nombre.compare(".") != 0 && nombre.compare("..") != 0)
            {
                malwares.push_back(nombre);
            }
        }
    }

    closedir(directorio);
}

void SHA1(const string &archivo)
{
    const string comando = "sha1sum Malware/" + archivo + " | awk '{printf \"%45s\\n\", $1}' >> hashes.txt";
    // const char *comandoSystem = comando.c_str();
    system(comando.c_str());
    // cout << comando<<endl;
}
void r2cmd(R2Pipe *r2, const char *cmd) {
	char *msg = r2pipe_cmd (r2, cmd);
	if (msg) {
		cout << msg<<endl;
		free (msg);
	}
}
void obtenerEnsamblador(const int &m, const string &archivo, const string &herramienta,vector<string>& ensambladores)
{
    string instruccion = "";
    if (herramienta.compare("Objdump") == 0)
    {
        instruccion = "objdump -d --no-show-raw-insn -M intel-mnemonic";
        const string comando = instruccion + " Malware/" + archivo + " | grep \"^ \" | cut -f2,3 > Ensambladores/" + herramienta + "/Ensamblador_m" + to_string(m) + string(".txt"); 
        system(comando.c_str());
    }
    else if (herramienta.compare("Radare2") == 0)
    {
        const string adress="r2 -q0 Malware/" + archivo;
        R2Pipe *r2 = r2pipe_open(adress.c_str());
        if (r2)
        {
            r2cmd(r2,"e asm.bytes=0");
            r2cmd(r2,"aaaa");
            const string comando2 = "pif@@f > Ensambladores/" + herramienta + "/Ensamblador_m" + to_string(m) + string(".txt");
            r2cmd(r2, comando2.c_str());
            r2pipe_close(r2);
        }else
            cout << "No se pudo abrir "<< "Malware/" + archivo<<endl;
    }
    ensambladores.push_back("Ensambladores/" + herramienta + "/Ensamblador_m" + to_string(m) + string(".txt"));
}

void getNGrams(const int& dm,const string& archivo,const string& herramienta){
    fstream file,fileout;

    unordered_map<string,int> unigrams;
    string linea;
    string opcode;
    file.open(archivo, ios::in);

    string salida="Resultados/"+herramienta+"/NgramD"+to_string(dm);
    fileout.open(salida, ios::out);
    while (getline(file,linea))
    {
        stringstream( linea ) >> opcode;
        if(unigrams.count(opcode))
            unigrams[opcode]++;
        else
            unigrams[opcode]=1;
    }

    fileout << "Opcode\t\t"<<"Frecuencia"<<endl;
    
    for (auto & unigram : unigrams)
    {
        fileout << left << setw(10)<< unigram.first<<"\t"<<unigram.second<<endl;
    }
    

    
}